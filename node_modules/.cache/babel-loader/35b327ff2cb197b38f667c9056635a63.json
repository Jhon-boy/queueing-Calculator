{"ast":null,"code":"import { TypeCalculate, SystemOrQueuing } from '../Constants';\nimport { Division } from '../../../utils/MathUtils';\nexport class MM1Model {\n  // basic values\n  // results\n  // constructor() {}\n  constructor(lambda, miu, n = 0) {\n    this.lambda = void 0;\n    this.miu = void 0;\n    this.n = void 0;\n    this.cola = void 0;\n    this.sistema = void 0;\n    this.servidor = void 0;\n    this.ro = 0;\n    this.p0 = 0;\n    this.pn = 0;\n    this.lq = 0;\n    this.l = 0;\n    this.wq = 0;\n    this.w = 0;\n    this.wn = 0;\n    this.ln = 0;\n    this.lambda = lambda;\n    this.miu = miu;\n    this.n = n;\n  }\n\n  isStatable() {\n    return Division(this.lambda, this.miu) < 1;\n  }\n\n  async calculateAll(system = SystemOrQueuing.System, typeCalculate = TypeCalculate.Fixed) {\n    // The probability of finding the busy system or system utilization (ρ)\n    this.ro = Division(this.lambda, this.miu);\n    this.p0 = this.getP0();\n    this.pn = this.getPn(system, typeCalculate);\n    this.lq = this.getLq();\n    this.l = this.getL();\n    this.w = this.getW();\n    this.wq = this.getWq();\n    this.wn = this.getWn();\n    this.ln = this.getLn();\n  } // The probability P0 of finding the empty or idle system\n\n\n  getP0() {\n    // return parseFloat((1 - this.ro).toPrecision(PRECISION));\n    return 1 - this.ro;\n  } // The probability Pn of finding exactly n customers in the system\n\n\n  getPn(system, typeCalculate) {\n    // fixed\n    if (typeCalculate === TypeCalculate.Fixed) {\n      return this.basicPn(this.n);\n    } // max\n\n\n    if (typeCalculate === TypeCalculate.Max) {\n      let value = 0;\n\n      if (system === SystemOrQueuing.System) {\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i); // console.log('MAX SYSTEM', value, i);\n        }\n      } else {\n        let end = this.n;\n        end++;\n\n        for (let i = 0; i <= end; i++) {\n          value += this.basicPn(i); // console.log('MAX QUEUING', value, i);\n        }\n      }\n\n      return value;\n    } // at least with system or queuing\n\n\n    if (system === SystemOrQueuing.System) {\n      let value = 0;\n\n      for (let i = 0; i < this.n; i++) {\n        value += this.basicPn(i);\n      }\n\n      return 1 - value;\n    } else {\n      let value = 0;\n\n      for (let i = 0; i <= this.n; i++) {\n        value += this.basicPn(i);\n      }\n\n      return 1 - value;\n    }\n  }\n\n  basicPn(elevate) {\n    let div = Math.pow(this.ro, elevate);\n    return this.p0 * div;\n  } // The expected number Lq of clients in the queue\n\n\n  getLq() {\n    let numerator = Math.pow(this.lambda, 2);\n    let denominator = this.miu * (this.miu - this.lambda);\n    return Division(numerator, denominator);\n  } // The expected number L of clients in the system\n\n\n  getL() {\n    let denominator = this.miu - this.lambda;\n    return Division(this.lambda, denominator);\n  } // The expected time Wq in the queue by the clients\n\n\n  getWq() {\n    let denominator = this.miu * (this.miu - this.lambda);\n    return Division(this.lambda, denominator);\n  } // The expected average time W in the system by the clients\n\n\n  getW() {\n    let denominator = this.miu - this.lambda;\n    return Division(1, denominator);\n  } // The expected number Ln of clients in the non-empty queue\n\n\n  getLn() {\n    let denominator = this.miu - this.lambda;\n    return Division(this.lambda, denominator);\n  } // The expected time Wn in the queue for queues not empty by clients\n\n\n  getWn() {\n    let denominator = this.miu - this.lambda;\n    return Division(1, denominator);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jhonc/Desktop/CALCULADORA/queueing-theory-calculator/src/library/queueing/formulas/MM1.model.ts"],"names":["TypeCalculate","SystemOrQueuing","Division","MM1Model","constructor","lambda","miu","n","cola","sistema","servidor","ro","p0","pn","lq","l","wq","w","wn","ln","isStatable","calculateAll","system","System","typeCalculate","Fixed","getP0","getPn","getLq","getL","getW","getWq","getWn","getLn","basicPn","Max","value","i","end","elevate","div","Math","pow","numerator","denominator"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,eAAxB,QAA+C,cAA/C;AACA,SAASC,QAAT,QAAyB,0BAAzB;AAqBA,OAAO,MAAMC,QAAN,CAAe;AACpB;AAOA;AAWA;AAEAC,EAAAA,WAAW,CAACC,MAAD,EAAiBC,GAAjB,EAA8BC,CAAS,GAAG,CAA1C,EAA+C;AAAA,SAnBjDF,MAmBiD;AAAA,SAlBjDC,GAkBiD;AAAA,SAjBjDC,CAiBiD;AAAA,SAhBjDC,IAgBiD;AAAA,SAfjDC,OAeiD;AAAA,SAdjDC,QAciD;AAAA,SAZ1DC,EAY0D,GAZ7C,CAY6C;AAAA,SAX1DC,EAW0D,GAX7C,CAW6C;AAAA,SAV1DC,EAU0D,GAV7C,CAU6C;AAAA,SAT1DC,EAS0D,GAT7C,CAS6C;AAAA,SAR1DC,CAQ0D,GAR9C,CAQ8C;AAAA,SAP1DC,EAO0D,GAP7C,CAO6C;AAAA,SAN1DC,CAM0D,GAN9C,CAM8C;AAAA,SAL1DC,EAK0D,GAL7C,CAK6C;AAAA,SAJ1DC,EAI0D,GAJ7C,CAI6C;AACxD,SAAKd,MAAL,GAAcA,MAAd;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,CAAL,GAASA,CAAT;AACD;;AAEDa,EAAAA,UAAU,GAAY;AACpB,WAAOlB,QAAQ,CAAC,KAAKG,MAAN,EAAc,KAAKC,GAAnB,CAAR,GAAkC,CAAzC;AACD;;AAEiB,QAAZe,YAAY,CAChBC,MAAuB,GAAGrB,eAAe,CAACsB,MAD1B,EAEhBC,aAA4B,GAAGxB,aAAa,CAACyB,KAF7B,EAGD;AACf;AACA,SAAKd,EAAL,GAAUT,QAAQ,CAAC,KAAKG,MAAN,EAAc,KAAKC,GAAnB,CAAlB;AACA,SAAKM,EAAL,GAAU,KAAKc,KAAL,EAAV;AACA,SAAKb,EAAL,GAAU,KAAKc,KAAL,CAAWL,MAAX,EAAmBE,aAAnB,CAAV;AACA,SAAKV,EAAL,GAAU,KAAKc,KAAL,EAAV;AACA,SAAKb,CAAL,GAAS,KAAKc,IAAL,EAAT;AACA,SAAKZ,CAAL,GAAS,KAAKa,IAAL,EAAT;AACA,SAAKd,EAAL,GAAU,KAAKe,KAAL,EAAV;AACA,SAAKb,EAAL,GAAU,KAAKc,KAAL,EAAV;AACA,SAAKb,EAAL,GAAU,KAAKc,KAAL,EAAV;AACD,GA7CmB,CA+CpB;;;AACQP,EAAAA,KAAK,GAAW;AACtB;AACA,WAAO,IAAI,KAAKf,EAAhB;AACD,GAnDmB,CAqDpB;;;AACQgB,EAAAA,KAAK,CAACL,MAAD,EAA0BE,aAA1B,EAAgE;AAC3E;AACA,QAAIA,aAAa,KAAKxB,aAAa,CAACyB,KAApC,EAA2C;AACzC,aAAO,KAAKS,OAAL,CAAa,KAAK3B,CAAlB,CAAP;AACD,KAJ0E,CAK3E;;;AACA,QAAIiB,aAAa,KAAKxB,aAAa,CAACmC,GAApC,EAAyC;AACvC,UAAIC,KAAK,GAAG,CAAZ;;AACA,UAAId,MAAM,KAAKrB,eAAe,CAACsB,MAA/B,EAAuC;AACrC,aAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,KAAK9B,CAA1B,EAA6B8B,CAAC,EAA9B,EAAkC;AAChCD,UAAAA,KAAK,IAAI,KAAKF,OAAL,CAAaG,CAAb,CAAT,CADgC,CAEhC;AACD;AACF,OALD,MAKO;AACL,YAAIC,GAAG,GAAG,KAAK/B,CAAf;AACA+B,QAAAA,GAAG;;AACH,aAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIC,GAArB,EAA0BD,CAAC,EAA3B,EAA+B;AAC7BD,UAAAA,KAAK,IAAI,KAAKF,OAAL,CAAaG,CAAb,CAAT,CAD6B,CAE7B;AACD;AACF;;AACD,aAAOD,KAAP;AACD,KAtB0E,CAuB3E;;;AACA,QAAId,MAAM,KAAKrB,eAAe,CAACsB,MAA/B,EAAuC;AACrC,UAAIa,KAAK,GAAG,CAAZ;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK9B,CAAzB,EAA4B8B,CAAC,EAA7B,EAAiC;AAC/BD,QAAAA,KAAK,IAAI,KAAKF,OAAL,CAAaG,CAAb,CAAT;AACD;;AACD,aAAO,IAAID,KAAX;AACD,KAND,MAMO;AACL,UAAIA,KAAK,GAAG,CAAZ;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,KAAK9B,CAA1B,EAA6B8B,CAAC,EAA9B,EAAkC;AAChCD,QAAAA,KAAK,IAAI,KAAKF,OAAL,CAAaG,CAAb,CAAT;AACD;;AACD,aAAO,IAAID,KAAX;AACD;AACF;;AAEOF,EAAAA,OAAO,CAACK,OAAD,EAA0B;AACvC,QAAIC,GAAG,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAK/B,EAAd,EAAkB4B,OAAlB,CAAV;AACA,WAAO,KAAK3B,EAAL,GAAU4B,GAAjB;AACD,GAhGmB,CAkGpB;;;AACQZ,EAAAA,KAAK,GAAW;AACtB,QAAIe,SAAS,GAAGF,IAAI,CAACC,GAAL,CAAS,KAAKrC,MAAd,EAAsB,CAAtB,CAAhB;AACA,QAAIuC,WAAW,GAAG,KAAKtC,GAAL,IAAY,KAAKA,GAAL,GAAW,KAAKD,MAA5B,CAAlB;AACA,WAAOH,QAAQ,CAACyC,SAAD,EAAYC,WAAZ,CAAf;AACD,GAvGmB,CAyGpB;;;AACQf,EAAAA,IAAI,GAAW;AACrB,QAAIe,WAAW,GAAG,KAAKtC,GAAL,GAAW,KAAKD,MAAlC;AACA,WAAOH,QAAQ,CAAC,KAAKG,MAAN,EAAcuC,WAAd,CAAf;AACD,GA7GmB,CA+GpB;;;AACQb,EAAAA,KAAK,GAAW;AACtB,QAAIa,WAAW,GAAG,KAAKtC,GAAL,IAAY,KAAKA,GAAL,GAAW,KAAKD,MAA5B,CAAlB;AACA,WAAOH,QAAQ,CAAC,KAAKG,MAAN,EAAcuC,WAAd,CAAf;AACD,GAnHmB,CAqHpB;;;AACQd,EAAAA,IAAI,GAAW;AACrB,QAAIc,WAAW,GAAG,KAAKtC,GAAL,GAAW,KAAKD,MAAlC;AACA,WAAOH,QAAQ,CAAC,CAAD,EAAI0C,WAAJ,CAAf;AACD,GAzHmB,CA2HpB;;;AACQX,EAAAA,KAAK,GAAW;AACtB,QAAIW,WAAW,GAAG,KAAKtC,GAAL,GAAW,KAAKD,MAAlC;AACA,WAAOH,QAAQ,CAAC,KAAKG,MAAN,EAAcuC,WAAd,CAAf;AACD,GA/HmB,CAiIpB;;;AACQZ,EAAAA,KAAK,GAAW;AACtB,QAAIY,WAAW,GAAG,KAAKtC,GAAL,GAAW,KAAKD,MAAlC;AACA,WAAOH,QAAQ,CAAC,CAAD,EAAI0C,WAAJ,CAAf;AACD;;AArImB","sourcesContent":["import { TypeCalculate, SystemOrQueuing } from '../Constants';\r\nimport { Division } from '../../../utils/MathUtils';\r\n\r\nexport interface MM1Type {\r\n  lambda: number;\r\n  miu: number;\r\n  n: number;\r\n  // results\r\n  ro: number;\r\n  p0: number;\r\n  pn: number;\r\n  lq: number;\r\n  l: number;\r\n  wq: number;\r\n  w: number;\r\n  wn: number;\r\n  ln: number;\r\n  cola:number;\r\n  sistema:number;\r\n  servidor:number;\r\n}\r\n\r\nexport class MM1Model {\r\n  // basic values\r\n  readonly lambda: number;\r\n  readonly miu: number;\r\n  readonly n: number;\r\n  readonly cola: number;\r\n  readonly sistema: number;\r\n  readonly servidor: number;\r\n  // results\r\n  ro: number = 0;\r\n  p0: number = 0;\r\n  pn: number = 0;\r\n  lq: number = 0;\r\n  l: number = 0;\r\n  wq: number = 0;\r\n  w: number = 0;\r\n  wn: number = 0;\r\n  ln: number = 0;\r\n\r\n  // constructor() {}\r\n\r\n  constructor(lambda: number, miu: number, n: number = 0, ) {\r\n    this.lambda = lambda;\r\n    this.miu = miu;\r\n    this.n = n;\r\n  }\r\n\r\n  isStatable(): boolean {\r\n    return Division(this.lambda, this.miu) < 1;\r\n  }\r\n\r\n  async calculateAll(\r\n    system: SystemOrQueuing = SystemOrQueuing.System,\r\n    typeCalculate: TypeCalculate = TypeCalculate.Fixed,\r\n  ): Promise<void> {\r\n    // The probability of finding the busy system or system utilization (ρ)\r\n    this.ro = Division(this.lambda, this.miu);\r\n    this.p0 = this.getP0();\r\n    this.pn = this.getPn(system, typeCalculate);\r\n    this.lq = this.getLq();\r\n    this.l = this.getL();\r\n    this.w = this.getW();\r\n    this.wq = this.getWq();\r\n    this.wn = this.getWn();\r\n    this.ln = this.getLn();\r\n  }\r\n\r\n  // The probability P0 of finding the empty or idle system\r\n  private getP0(): number {\r\n    // return parseFloat((1 - this.ro).toPrecision(PRECISION));\r\n    return 1 - this.ro;\r\n  }\r\n\r\n  // The probability Pn of finding exactly n customers in the system\r\n  private getPn(system: SystemOrQueuing, typeCalculate: TypeCalculate): number {\r\n    // fixed\r\n    if (typeCalculate === TypeCalculate.Fixed) {\r\n      return this.basicPn(this.n);\r\n    }\r\n    // max\r\n    if (typeCalculate === TypeCalculate.Max) {\r\n      let value = 0;\r\n      if (system === SystemOrQueuing.System) {\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n          // console.log('MAX SYSTEM', value, i);\r\n        }\r\n      } else {\r\n        let end = this.n;\r\n        end++;\r\n        for (let i = 0; i <= end; i++) {\r\n          value += this.basicPn(i);\r\n          // console.log('MAX QUEUING', value, i);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n    // at least with system or queuing\r\n    if (system === SystemOrQueuing.System) {\r\n      let value = 0;\r\n      for (let i = 0; i < this.n; i++) {\r\n        value += this.basicPn(i);\r\n      }\r\n      return 1 - value;\r\n    } else {\r\n      let value = 0;\r\n      for (let i = 0; i <= this.n; i++) {\r\n        value += this.basicPn(i);\r\n      }\r\n      return 1 - value;\r\n    }\r\n  }\r\n\r\n  private basicPn(elevate: number): number {\r\n    let div = Math.pow(this.ro, elevate);\r\n    return this.p0 * div;\r\n  }\r\n\r\n  // The expected number Lq of clients in the queue\r\n  private getLq(): number {\r\n    let numerator = Math.pow(this.lambda, 2);\r\n    let denominator = this.miu * (this.miu - this.lambda);\r\n    return Division(numerator, denominator);\r\n  }\r\n\r\n  // The expected number L of clients in the system\r\n  private getL(): number {\r\n    let denominator = this.miu - this.lambda;\r\n    return Division(this.lambda, denominator);\r\n  }\r\n\r\n  // The expected time Wq in the queue by the clients\r\n  private getWq(): number {\r\n    let denominator = this.miu * (this.miu - this.lambda);\r\n    return Division(this.lambda, denominator);\r\n  }\r\n\r\n  // The expected average time W in the system by the clients\r\n  private getW(): number {\r\n    let denominator = this.miu - this.lambda;\r\n    return Division(1, denominator);\r\n  }\r\n\r\n  // The expected number Ln of clients in the non-empty queue\r\n  private getLn(): number {\r\n    let denominator = this.miu - this.lambda;\r\n    return Division(this.lambda, denominator);\r\n  }\r\n\r\n  // The expected time Wn in the queue for queues not empty by clients\r\n  private getWn(): number {\r\n    let denominator = this.miu - this.lambda;\r\n    return Division(1, denominator);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}