{"ast":null,"code":"import { SystemOrQueuing, TypeCalculate } from '../Constants';\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\nexport class MMKMMModel {\n  // basic values\n  // results\n  constructor(lambda, miu, k, m, n = 0) {\n    this.lambda = void 0;\n    this.miu = void 0;\n    this.m = void 0;\n    this.k = void 0;\n    this.n = void 0;\n    this.p0 = 0;\n    this.pe = 0;\n    this.pne = 0;\n    this.pn = 0;\n    this.lq = 0;\n    this.l = 0;\n    this.wq = 0;\n    this.w = 0;\n    this.wn = 0;\n    this.ln = 0;\n    this.lambda = lambda;\n    this.miu = miu;\n    this.k = k;\n    this.m = m;\n    this.n = n;\n  }\n\n  isMultichannel() {\n    return this.k > 1;\n  }\n\n  async calculateAll(system = SystemOrQueuing.System, typeCalculate = TypeCalculate.Fixed) {\n    this.p0 = this.getP0();\n    this.pn = this.getPn(system, typeCalculate);\n    this.pe = this.getPe();\n    this.pne = 1 - this.pe;\n    this.l = this.getL();\n    this.lq = this.getLq();\n    this.ln = this.getLn();\n    this.wq = this.getWq();\n    this.w = this.getW();\n    this.wn = this.getWn();\n  } // The probability P0 of finding the empty or idle system\n\n\n  getP0() {\n    // summation\n    let summation1 = this.summation1ForP0();\n    let summation2 = this.summation2ForP0();\n    return Division(1, summation1 + summation2);\n  }\n\n  summation1ForP0() {\n    let value = 0;\n\n    for (let n = 0; n <= parseInt(this.k.toString()) - 1; n++) {\n      // M!\n      let fact = Factorial(this.m); // (M - n)!\n\n      let subItem1 = Factorial(this.m - n); // n!\n\n      let subItem2 = Factorial(n); // (M - n)!n!\n\n      let denominator = subItem1 * subItem2; // M! / (M - n)!n!\n\n      let item1 = Division(fact, denominator); // (lambda/miu)^n\n\n      let div = Division(this.lambda, this.miu);\n      let item2 = Power(div, n);\n      let operation = item1 * item2;\n      value += operation;\n    }\n\n    return value;\n  }\n\n  summation2ForP0() {\n    let value = 0;\n\n    for (let n = this.k; n <= this.m; n++) {\n      // M!\n      let fact = Factorial(this.m); // (M - n)!\n\n      let subItem1 = Factorial(this.m - n); // k!\n\n      let subItem2 = Factorial(this.k); // k^n-k\n\n      let subItem3 = Power(this.k, n - this.k); // (M - n)!k!k^n-k\n\n      let denominator = subItem1 * subItem2 * subItem3; // M! / (M - n)!k!k^n-k\n\n      let item1 = Division(fact, denominator); // (lambda/miu)^n\n\n      let div = Division(this.lambda, this.miu);\n      let item2 = Power(div, n);\n      let operation = item1 * item2;\n      value += operation;\n    }\n\n    return value;\n  } // The probability Pn of finding exactly n customers in the system\n\n\n  getPn(system, typeCalculate) {\n    // Calculate Pn to finding client on System\n    if (system === SystemOrQueuing.System) {\n      // fixed SYSTEM\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n);\n      } // max SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i); // console.log('MAX SYSTEM', value, i);\n        }\n\n        return value;\n      } // at least SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i < this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    } // Calculate Pn to finding client on Queuing\n\n\n    if (system === SystemOrQueuing.Queuing) {\n      // fixed Queuing\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n + this.k);\n      } // max Queuing\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n        let end = this.n + this.k;\n\n        for (let i = 0; i <= end; i++) {\n          value += this.basicPn(i);\n        }\n\n        return value;\n      } // at least Queuing\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    }\n\n    return 0;\n  }\n\n  basicPn(n) {\n    if (0 <= n && n < this.k) {\n      return this.calculatePnWhenNLessK(n);\n    } else {\n      return this.calculatePnWhenNHigherK(n);\n    }\n  }\n\n  calculatePnWhenNLessK(n) {\n    // M!\n    let fact = Factorial(this.m); // (M - n)!\n\n    let subItem1 = Factorial(this.m - n); // n!\n\n    let subItem2 = Factorial(n); // (M - n)!n!\n\n    let denominator = subItem1 * subItem2; // M! / (M - n)!n!\n\n    let item1 = Division(fact, denominator); // (lambda/miu)^n\n\n    let div = Division(this.lambda, this.miu);\n    let item2 = Power(div, n);\n    return this.p0 * item1 * item2;\n  }\n\n  calculatePnWhenNHigherK(n) {\n    // M!\n    let fact = Factorial(this.m); // (M - n)!\n\n    let subItem1 = Factorial(this.m - n); // k!\n\n    let subItem2 = Factorial(this.k); // k^n-k\n\n    let subItem3 = Power(this.k, n - this.k); // (M - n)!k!k^n-k\n\n    let denominator = subItem1 * subItem2 * subItem3; // M! / (M - n)!k!k^n-k\n\n    let item1 = Division(fact, denominator); // (lambda/miu)^n\n\n    let div = Division(this.lambda, this.miu);\n    let item2 = Power(div, n);\n    return this.p0 * item1 * item2;\n  } // The probability Pe of finding the system busy\n\n\n  getPe() {\n    let value = 0;\n\n    for (let n = this.k; n <= this.m; n++) {\n      value += this.basicPn(n);\n    }\n\n    return value;\n  } // The expected number L of clients in the system\n\n\n  getL() {\n    let sum1 = this.summation1ForL();\n    let sum2 = this.summation2ForL();\n    let sum3 = this.summation3ForL();\n    return sum1 + sum2 + sum3;\n  }\n\n  summation1ForL() {\n    let value = 0;\n    let end = this.k - 1;\n\n    for (let n = 0; n <= end; n++) {\n      // n*Pn\n      let operation = n * this.basicPn(n);\n      value += operation;\n    }\n\n    return value;\n  }\n\n  summation2ForL() {\n    let value = 0;\n\n    for (let n = this.k; n <= this.m; n++) {\n      // n - k\n      let item1 = n - this.k; // Pn\n\n      let item2 = this.basicPn(n); // (n - k) *Pn\n\n      let operation = item1 * item2;\n      value += operation;\n    }\n\n    return value;\n  }\n\n  summation3ForL() {\n    let value = 0;\n    let end = this.k - 1;\n\n    for (let n = 0; n <= end; n++) {\n      value += this.basicPn(n);\n    } // 1 - sum(Pn)\n\n\n    let item1 = 1 - value; // k * (1 - sum(Pn))\n\n    return this.k * item1;\n  } // The expected number Lq of clients in the queue\n\n\n  getLq() {\n    let value = 0;\n\n    for (let n = this.k; n <= this.m; n++) {\n      // n - k\n      let item1 = n - this.k; // Pn\n\n      let item2 = this.basicPn(n); // (n - k) * Pn\n\n      let operation = item1 * item2;\n      value += operation;\n    }\n\n    return value;\n  } // The expected number Ln of clients in the non-empty queue\n\n\n  getLn() {\n    return Division(this.lq, this.pe);\n  } // The expected time Wq in the queue by the clients\n\n\n  getWq() {\n    // (M - L) * lambda\n    let denominator = (this.m - this.l) * this.lambda;\n    return Division(this.lq, denominator);\n  } // The expected average time W in the system by the clients\n\n\n  getW() {\n    // 1 / miu\n    let item2 = Division(1, this.miu); // Wq + (1 / miu)\n\n    return this.wq + item2;\n  } // The expected time Wn in the queue for queues not empty by clients\n\n\n  getWn() {\n    return Division(this.wq, this.pe);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jhonc/Desktop/CALCULADORA/queueing-theory-calculator/src/library/queueing/formulas/MMKMM.model.ts"],"names":["SystemOrQueuing","TypeCalculate","Division","Factorial","Power","MMKMMModel","constructor","lambda","miu","k","m","n","p0","pe","pne","pn","lq","l","wq","w","wn","ln","isMultichannel","calculateAll","system","System","typeCalculate","Fixed","getP0","getPn","getPe","getL","getLq","getLn","getWq","getW","getWn","summation1","summation1ForP0","summation2","summation2ForP0","value","parseInt","toString","fact","subItem1","subItem2","denominator","item1","div","item2","operation","subItem3","basicPn","Max","i","AtLeast","Queuing","end","calculatePnWhenNLessK","calculatePnWhenNHigherK","sum1","summation1ForL","sum2","summation2ForL","sum3","summation3ForL"],"mappings":"AAAA,SAASA,eAAT,EAA0BC,aAA1B,QAA+C,cAA/C;AACA,SAASC,QAAT,EAAmBC,SAAnB,EAA8BC,KAA9B,QAA2C,4BAA3C;AAEA,OAAO,MAAMC,UAAN,CAAiB;AACtB;AAMA;AAaAC,EAAAA,WAAW,CACTC,MADS,EAETC,GAFS,EAGTC,CAHS,EAITC,CAJS,EAKTC,CAAS,GAAG,CALH,EAMT;AAAA,SAxBOJ,MAwBP;AAAA,SAvBOC,GAuBP;AAAA,SAtBOE,CAsBP;AAAA,SArBOD,CAqBP;AAAA,SApBOE,CAoBP;AAAA,SAlBFC,EAkBE,GAlBW,CAkBX;AAAA,SAjBFC,EAiBE,GAjBW,CAiBX;AAAA,SAhBFC,GAgBE,GAhBY,CAgBZ;AAAA,SAdFC,EAcE,GAdW,CAcX;AAAA,SAbFC,EAaE,GAbW,CAaX;AAAA,SAZFC,CAYE,GAZU,CAYV;AAAA,SAXFC,EAWE,GAXW,CAWX;AAAA,SAVFC,CAUE,GAVU,CAUV;AAAA,SATFC,EASE,GATW,CASX;AAAA,SARFC,EAQE,GARW,CAQX;AACA,SAAKd,MAAL,GAAcA,MAAd;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACD;;AAEDW,EAAAA,cAAc,GAAY;AACxB,WAAO,KAAKb,CAAL,GAAS,CAAhB;AACD;;AAEiB,QAAZc,YAAY,CAChBC,MAAuB,GAAGxB,eAAe,CAACyB,MAD1B,EAEhBC,aAA4B,GAAGzB,aAAa,CAAC0B,KAF7B,EAGD;AACf,SAAKf,EAAL,GAAU,KAAKgB,KAAL,EAAV;AACA,SAAKb,EAAL,GAAU,KAAKc,KAAL,CAAWL,MAAX,EAAmBE,aAAnB,CAAV;AACA,SAAKb,EAAL,GAAU,KAAKiB,KAAL,EAAV;AACA,SAAKhB,GAAL,GAAW,IAAI,KAAKD,EAApB;AACA,SAAKI,CAAL,GAAS,KAAKc,IAAL,EAAT;AACA,SAAKf,EAAL,GAAU,KAAKgB,KAAL,EAAV;AACA,SAAKX,EAAL,GAAU,KAAKY,KAAL,EAAV;AACA,SAAKf,EAAL,GAAU,KAAKgB,KAAL,EAAV;AAEA,SAAKf,CAAL,GAAS,KAAKgB,IAAL,EAAT;AACA,SAAKf,EAAL,GAAU,KAAKgB,KAAL,EAAV;AACD,GArDqB,CAuDtB;;;AACQR,EAAAA,KAAK,GAAW;AACtB;AACA,QAAIS,UAAU,GAAG,KAAKC,eAAL,EAAjB;AACA,QAAIC,UAAU,GAAG,KAAKC,eAAL,EAAjB;AAEA,WAAOtC,QAAQ,CAAC,CAAD,EAAImC,UAAU,GAAGE,UAAjB,CAAf;AACD;;AAEOD,EAAAA,eAAe,GAAW;AAChC,QAAIG,KAAK,GAAG,CAAZ;;AACA,SAAK,IAAI9B,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI+B,QAAQ,CAAC,KAAKjC,CAAL,CAAOkC,QAAP,EAAD,CAAR,GAA8B,CAAnD,EAAsDhC,CAAC,EAAvD,EAA2D;AACzD;AACA,UAAIiC,IAAI,GAAGzC,SAAS,CAAC,KAAKO,CAAN,CAApB,CAFyD,CAGzD;;AACA,UAAImC,QAAQ,GAAG1C,SAAS,CAAC,KAAKO,CAAL,GAASC,CAAV,CAAxB,CAJyD,CAKzD;;AACA,UAAImC,QAAQ,GAAG3C,SAAS,CAACQ,CAAD,CAAxB,CANyD,CAOzD;;AACA,UAAIoC,WAAW,GAAGF,QAAQ,GAAGC,QAA7B,CARyD,CASzD;;AACA,UAAIE,KAAK,GAAG9C,QAAQ,CAAC0C,IAAD,EAAOG,WAAP,CAApB,CAVyD,CAYzD;;AACA,UAAIE,GAAG,GAAG/C,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAlB;AACA,UAAI0C,KAAK,GAAG9C,KAAK,CAAC6C,GAAD,EAAMtC,CAAN,CAAjB;AAEA,UAAIwC,SAAS,GAAGH,KAAK,GAAGE,KAAxB;AACAT,MAAAA,KAAK,IAAIU,SAAT;AACD;;AACD,WAAOV,KAAP;AACD;;AAEOD,EAAAA,eAAe,GAAW;AAChC,QAAIC,KAAK,GAAG,CAAZ;;AACA,SAAK,IAAI9B,CAAC,GAAG,KAAKF,CAAlB,EAAqBE,CAAC,IAAI,KAAKD,CAA/B,EAAkCC,CAAC,EAAnC,EAAuC;AACrC;AACA,UAAIiC,IAAI,GAAGzC,SAAS,CAAC,KAAKO,CAAN,CAApB,CAFqC,CAGrC;;AACA,UAAImC,QAAQ,GAAG1C,SAAS,CAAC,KAAKO,CAAL,GAASC,CAAV,CAAxB,CAJqC,CAKrC;;AACA,UAAImC,QAAQ,GAAG3C,SAAS,CAAC,KAAKM,CAAN,CAAxB,CANqC,CAOrC;;AACA,UAAI2C,QAAQ,GAAGhD,KAAK,CAAC,KAAKK,CAAN,EAASE,CAAC,GAAG,KAAKF,CAAlB,CAApB,CARqC,CASrC;;AACA,UAAIsC,WAAW,GAAGF,QAAQ,GAAGC,QAAX,GAAsBM,QAAxC,CAVqC,CAWrC;;AACA,UAAIJ,KAAK,GAAG9C,QAAQ,CAAC0C,IAAD,EAAOG,WAAP,CAApB,CAZqC,CAcrC;;AACA,UAAIE,GAAG,GAAG/C,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAlB;AACA,UAAI0C,KAAK,GAAG9C,KAAK,CAAC6C,GAAD,EAAMtC,CAAN,CAAjB;AAEA,UAAIwC,SAAS,GAAGH,KAAK,GAAGE,KAAxB;AACAT,MAAAA,KAAK,IAAIU,SAAT;AACD;;AACD,WAAOV,KAAP;AACD,GAhHqB,CAkHtB;;;AACQZ,EAAAA,KAAK,CAACL,MAAD,EAA0BE,aAA1B,EAAgE;AAC3E;AACA,QAAIF,MAAM,KAAKxB,eAAe,CAACyB,MAA/B,EAAuC;AACrC;AACA,UAAIC,aAAa,KAAKzB,aAAa,CAAC0B,KAApC,EAA2C;AACzC,eAAO,KAAK0B,OAAL,CAAa,KAAK1C,CAAlB,CAAP;AACD,OAJoC,CAMrC;;;AACA,UAAIe,aAAa,KAAKzB,aAAa,CAACqD,GAApC,EAAyC;AACvC,YAAIb,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,KAAK5C,CAA1B,EAA6B4C,CAAC,EAA9B,EAAkC;AAChCd,UAAAA,KAAK,IAAI,KAAKY,OAAL,CAAaE,CAAb,CAAT,CADgC,CAEhC;AACD;;AACD,eAAOd,KAAP;AACD,OAdoC,CAgBrC;;;AACA,UAAIf,aAAa,KAAKzB,aAAa,CAACuD,OAApC,EAA6C;AAC3C,YAAIf,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK5C,CAAzB,EAA4B4C,CAAC,EAA7B,EAAiC;AAC/Bd,UAAAA,KAAK,IAAI,KAAKY,OAAL,CAAaE,CAAb,CAAT;AACD;;AACD,eAAO,IAAId,KAAX;AACD;AACF,KA1B0E,CA2B3E;;;AACA,QAAIjB,MAAM,KAAKxB,eAAe,CAACyD,OAA/B,EAAwC;AACtC;AACA,UAAI/B,aAAa,KAAKzB,aAAa,CAAC0B,KAApC,EAA2C;AACzC,eAAO,KAAK0B,OAAL,CAAa,KAAK1C,CAAL,GAAS,KAAKF,CAA3B,CAAP;AACD,OAJqC,CAMtC;;;AACA,UAAIiB,aAAa,KAAKzB,aAAa,CAACqD,GAApC,EAAyC;AACvC,YAAIb,KAAK,GAAG,CAAZ;AACA,YAAIiB,GAAG,GAAG,KAAK/C,CAAL,GAAS,KAAKF,CAAxB;;AACA,aAAK,IAAI8C,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIG,GAArB,EAA0BH,CAAC,EAA3B,EAA+B;AAC7Bd,UAAAA,KAAK,IAAI,KAAKY,OAAL,CAAaE,CAAb,CAAT;AACD;;AACD,eAAOd,KAAP;AACD,OAdqC,CAgBtC;;;AACA,UAAIf,aAAa,KAAKzB,aAAa,CAACuD,OAApC,EAA6C;AAC3C,YAAIf,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,KAAK5C,CAA1B,EAA6B4C,CAAC,EAA9B,EAAkC;AAChCd,UAAAA,KAAK,IAAI,KAAKY,OAAL,CAAaE,CAAb,CAAT;AACD;;AACD,eAAO,IAAId,KAAX;AACD;AACF;;AAED,WAAO,CAAP;AACD;;AAEOY,EAAAA,OAAO,CAAC1C,CAAD,EAAoB;AACjC,QAAI,KAAKA,CAAL,IAAUA,CAAC,GAAG,KAAKF,CAAvB,EAA0B;AACxB,aAAO,KAAKkD,qBAAL,CAA2BhD,CAA3B,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAKiD,uBAAL,CAA6BjD,CAA7B,CAAP;AACD;AACF;;AAEOgD,EAAAA,qBAAqB,CAAChD,CAAD,EAAoB;AAC/C;AACA,QAAIiC,IAAI,GAAGzC,SAAS,CAAC,KAAKO,CAAN,CAApB,CAF+C,CAG/C;;AACA,QAAImC,QAAQ,GAAG1C,SAAS,CAAC,KAAKO,CAAL,GAASC,CAAV,CAAxB,CAJ+C,CAK/C;;AACA,QAAImC,QAAQ,GAAG3C,SAAS,CAACQ,CAAD,CAAxB,CAN+C,CAO/C;;AACA,QAAIoC,WAAW,GAAGF,QAAQ,GAAGC,QAA7B,CAR+C,CAS/C;;AACA,QAAIE,KAAK,GAAG9C,QAAQ,CAAC0C,IAAD,EAAOG,WAAP,CAApB,CAV+C,CAY/C;;AACA,QAAIE,GAAG,GAAG/C,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAlB;AACA,QAAI0C,KAAK,GAAG9C,KAAK,CAAC6C,GAAD,EAAMtC,CAAN,CAAjB;AAEA,WAAO,KAAKC,EAAL,GAAUoC,KAAV,GAAkBE,KAAzB;AACD;;AAEOU,EAAAA,uBAAuB,CAACjD,CAAD,EAAoB;AACjD;AACA,QAAIiC,IAAI,GAAGzC,SAAS,CAAC,KAAKO,CAAN,CAApB,CAFiD,CAGjD;;AACA,QAAImC,QAAQ,GAAG1C,SAAS,CAAC,KAAKO,CAAL,GAASC,CAAV,CAAxB,CAJiD,CAKjD;;AACA,QAAImC,QAAQ,GAAG3C,SAAS,CAAC,KAAKM,CAAN,CAAxB,CANiD,CAOjD;;AACA,QAAI2C,QAAQ,GAAGhD,KAAK,CAAC,KAAKK,CAAN,EAASE,CAAC,GAAG,KAAKF,CAAlB,CAApB,CARiD,CASjD;;AACA,QAAIsC,WAAW,GAAGF,QAAQ,GAAGC,QAAX,GAAsBM,QAAxC,CAViD,CAWjD;;AACA,QAAIJ,KAAK,GAAG9C,QAAQ,CAAC0C,IAAD,EAAOG,WAAP,CAApB,CAZiD,CAcjD;;AACA,QAAIE,GAAG,GAAG/C,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAlB;AACA,QAAI0C,KAAK,GAAG9C,KAAK,CAAC6C,GAAD,EAAMtC,CAAN,CAAjB;AAEA,WAAO,KAAKC,EAAL,GAAUoC,KAAV,GAAkBE,KAAzB;AACD,GA1NqB,CA4NtB;;;AACQpB,EAAAA,KAAK,GAAW;AACtB,QAAIW,KAAK,GAAG,CAAZ;;AACA,SAAK,IAAI9B,CAAC,GAAG,KAAKF,CAAlB,EAAqBE,CAAC,IAAI,KAAKD,CAA/B,EAAkCC,CAAC,EAAnC,EAAuC;AACrC8B,MAAAA,KAAK,IAAI,KAAKY,OAAL,CAAa1C,CAAb,CAAT;AACD;;AACD,WAAO8B,KAAP;AACD,GAnOqB,CAqOtB;;;AACQV,EAAAA,IAAI,GAAW;AACrB,QAAI8B,IAAI,GAAG,KAAKC,cAAL,EAAX;AACA,QAAIC,IAAI,GAAG,KAAKC,cAAL,EAAX;AACA,QAAIC,IAAI,GAAG,KAAKC,cAAL,EAAX;AACA,WAAOL,IAAI,GAAGE,IAAP,GAAcE,IAArB;AACD;;AAEDH,EAAAA,cAAc,GAAW;AACvB,QAAIrB,KAAK,GAAG,CAAZ;AACA,QAAIiB,GAAG,GAAG,KAAKjD,CAAL,GAAS,CAAnB;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI+C,GAArB,EAA0B/C,CAAC,EAA3B,EAA+B;AAC7B;AACA,UAAIwC,SAAS,GAAGxC,CAAC,GAAG,KAAK0C,OAAL,CAAa1C,CAAb,CAApB;AACA8B,MAAAA,KAAK,IAAIU,SAAT;AACD;;AACD,WAAOV,KAAP;AACD;;AAEDuB,EAAAA,cAAc,GAAW;AACvB,QAAIvB,KAAK,GAAG,CAAZ;;AACA,SAAK,IAAI9B,CAAC,GAAG,KAAKF,CAAlB,EAAqBE,CAAC,IAAI,KAAKD,CAA/B,EAAkCC,CAAC,EAAnC,EAAuC;AACrC;AACA,UAAIqC,KAAK,GAAGrC,CAAC,GAAG,KAAKF,CAArB,CAFqC,CAGrC;;AACA,UAAIyC,KAAK,GAAG,KAAKG,OAAL,CAAa1C,CAAb,CAAZ,CAJqC,CAKrC;;AACA,UAAIwC,SAAS,GAAGH,KAAK,GAAGE,KAAxB;AACAT,MAAAA,KAAK,IAAIU,SAAT;AACD;;AACD,WAAOV,KAAP;AACD;;AAEDyB,EAAAA,cAAc,GAAW;AACvB,QAAIzB,KAAK,GAAG,CAAZ;AACA,QAAIiB,GAAG,GAAG,KAAKjD,CAAL,GAAS,CAAnB;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI+C,GAArB,EAA0B/C,CAAC,EAA3B,EAA+B;AAC7B8B,MAAAA,KAAK,IAAI,KAAKY,OAAL,CAAa1C,CAAb,CAAT;AACD,KALsB,CAMvB;;;AACA,QAAIqC,KAAK,GAAG,IAAIP,KAAhB,CAPuB,CAQvB;;AACA,WAAO,KAAKhC,CAAL,GAASuC,KAAhB;AACD,GAhRqB,CAkRtB;;;AACQhB,EAAAA,KAAK,GAAW;AACtB,QAAIS,KAAK,GAAG,CAAZ;;AACA,SAAK,IAAI9B,CAAC,GAAG,KAAKF,CAAlB,EAAqBE,CAAC,IAAI,KAAKD,CAA/B,EAAkCC,CAAC,EAAnC,EAAuC;AACrC;AACA,UAAIqC,KAAK,GAAGrC,CAAC,GAAG,KAAKF,CAArB,CAFqC,CAGrC;;AACA,UAAIyC,KAAK,GAAG,KAAKG,OAAL,CAAa1C,CAAb,CAAZ,CAJqC,CAKrC;;AACA,UAAIwC,SAAS,GAAGH,KAAK,GAAGE,KAAxB;AACAT,MAAAA,KAAK,IAAIU,SAAT;AACD;;AACD,WAAOV,KAAP;AACD,GA/RqB,CAiStB;;;AACQR,EAAAA,KAAK,GAAW;AACtB,WAAO/B,QAAQ,CAAC,KAAKc,EAAN,EAAU,KAAKH,EAAf,CAAf;AACD,GApSqB,CAsStB;;;AACQqB,EAAAA,KAAK,GAAW;AACtB;AACA,QAAIa,WAAW,GAAG,CAAC,KAAKrC,CAAL,GAAS,KAAKO,CAAf,IAAoB,KAAKV,MAA3C;AACA,WAAOL,QAAQ,CAAC,KAAKc,EAAN,EAAU+B,WAAV,CAAf;AACD,GA3SqB,CA6StB;;;AACQZ,EAAAA,IAAI,GAAW;AACrB;AACA,QAAIe,KAAK,GAAGhD,QAAQ,CAAC,CAAD,EAAI,KAAKM,GAAT,CAApB,CAFqB,CAGrB;;AACA,WAAO,KAAKU,EAAL,GAAUgC,KAAjB;AACD,GAnTqB,CAqTtB;;;AACQd,EAAAA,KAAK,GAAW;AACtB,WAAOlC,QAAQ,CAAC,KAAKgB,EAAN,EAAU,KAAKL,EAAf,CAAf;AACD;;AAxTqB","sourcesContent":["import { SystemOrQueuing, TypeCalculate } from '../Constants';\r\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\r\n\r\nexport class MMKMMModel {\r\n  // basic values\r\n  readonly lambda: number;\r\n  readonly miu: number;\r\n  readonly m: number;\r\n  readonly k: number;\r\n  readonly n: number;\r\n  // results\r\n  p0: number = 0;\r\n  pe: number = 0;\r\n  pne: number = 0;\r\n\r\n  pn: number = 0;\r\n  lq: number = 0;\r\n  l: number = 0;\r\n  wq: number = 0;\r\n  w: number = 0;\r\n  wn: number = 0;\r\n  ln: number = 0;\r\n\r\n  constructor(\r\n    lambda: number,\r\n    miu: number,\r\n    k: number,\r\n    m: number,\r\n    n: number = 0,\r\n  ) {\r\n    this.lambda = lambda;\r\n    this.miu = miu;\r\n    this.k = k;\r\n    this.m = m;\r\n    this.n = n;\r\n  }\r\n\r\n  isMultichannel(): boolean {\r\n    return this.k > 1;\r\n  }\r\n\r\n  async calculateAll(\r\n    system: SystemOrQueuing = SystemOrQueuing.System,\r\n    typeCalculate: TypeCalculate = TypeCalculate.Fixed,\r\n  ): Promise<void> {\r\n    this.p0 = this.getP0();\r\n    this.pn = this.getPn(system, typeCalculate);\r\n    this.pe = this.getPe();\r\n    this.pne = 1 - this.pe;\r\n    this.l = this.getL();\r\n    this.lq = this.getLq();\r\n    this.ln = this.getLn();\r\n    this.wq = this.getWq();\r\n\r\n    this.w = this.getW();\r\n    this.wn = this.getWn();\r\n  }\r\n\r\n  // The probability P0 of finding the empty or idle system\r\n  private getP0(): number {\r\n    // summation\r\n    let summation1 = this.summation1ForP0();\r\n    let summation2 = this.summation2ForP0();\r\n\r\n    return Division(1, summation1 + summation2);\r\n  }\r\n\r\n  private summation1ForP0(): number {\r\n    let value = 0;\r\n    for (let n = 0; n <= parseInt(this.k.toString()) - 1; n++) {\r\n      // M!\r\n      let fact = Factorial(this.m);\r\n      // (M - n)!\r\n      let subItem1 = Factorial(this.m - n);\r\n      // n!\r\n      let subItem2 = Factorial(n);\r\n      // (M - n)!n!\r\n      let denominator = subItem1 * subItem2;\r\n      // M! / (M - n)!n!\r\n      let item1 = Division(fact, denominator);\r\n\r\n      // (lambda/miu)^n\r\n      let div = Division(this.lambda, this.miu);\r\n      let item2 = Power(div, n);\r\n\r\n      let operation = item1 * item2;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  private summation2ForP0(): number {\r\n    let value = 0;\r\n    for (let n = this.k; n <= this.m; n++) {\r\n      // M!\r\n      let fact = Factorial(this.m);\r\n      // (M - n)!\r\n      let subItem1 = Factorial(this.m - n);\r\n      // k!\r\n      let subItem2 = Factorial(this.k);\r\n      // k^n-k\r\n      let subItem3 = Power(this.k, n - this.k);\r\n      // (M - n)!k!k^n-k\r\n      let denominator = subItem1 * subItem2 * subItem3;\r\n      // M! / (M - n)!k!k^n-k\r\n      let item1 = Division(fact, denominator);\r\n\r\n      // (lambda/miu)^n\r\n      let div = Division(this.lambda, this.miu);\r\n      let item2 = Power(div, n);\r\n\r\n      let operation = item1 * item2;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The probability Pn of finding exactly n customers in the system\r\n  private getPn(system: SystemOrQueuing, typeCalculate: TypeCalculate): number {\r\n    // Calculate Pn to finding client on System\r\n    if (system === SystemOrQueuing.System) {\r\n      // fixed SYSTEM\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n);\r\n      }\r\n\r\n      // max SYSTEM\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n          // console.log('MAX SYSTEM', value, i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least SYSTEM\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i < this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n    // Calculate Pn to finding client on Queuing\r\n    if (system === SystemOrQueuing.Queuing) {\r\n      // fixed Queuing\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n + this.k);\r\n      }\r\n\r\n      // max Queuing\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        let end = this.n + this.k;\r\n        for (let i = 0; i <= end; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least Queuing\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  private basicPn(n: number): number {\r\n    if (0 <= n && n < this.k) {\r\n      return this.calculatePnWhenNLessK(n);\r\n    } else {\r\n      return this.calculatePnWhenNHigherK(n);\r\n    }\r\n  }\r\n\r\n  private calculatePnWhenNLessK(n: number): number {\r\n    // M!\r\n    let fact = Factorial(this.m);\r\n    // (M - n)!\r\n    let subItem1 = Factorial(this.m - n);\r\n    // n!\r\n    let subItem2 = Factorial(n);\r\n    // (M - n)!n!\r\n    let denominator = subItem1 * subItem2;\r\n    // M! / (M - n)!n!\r\n    let item1 = Division(fact, denominator);\r\n\r\n    // (lambda/miu)^n\r\n    let div = Division(this.lambda, this.miu);\r\n    let item2 = Power(div, n);\r\n\r\n    return this.p0 * item1 * item2;\r\n  }\r\n\r\n  private calculatePnWhenNHigherK(n: number): number {\r\n    // M!\r\n    let fact = Factorial(this.m);\r\n    // (M - n)!\r\n    let subItem1 = Factorial(this.m - n);\r\n    // k!\r\n    let subItem2 = Factorial(this.k);\r\n    // k^n-k\r\n    let subItem3 = Power(this.k, n - this.k);\r\n    // (M - n)!k!k^n-k\r\n    let denominator = subItem1 * subItem2 * subItem3;\r\n    // M! / (M - n)!k!k^n-k\r\n    let item1 = Division(fact, denominator);\r\n\r\n    // (lambda/miu)^n\r\n    let div = Division(this.lambda, this.miu);\r\n    let item2 = Power(div, n);\r\n\r\n    return this.p0 * item1 * item2;\r\n  }\r\n\r\n  // The probability Pe of finding the system busy\r\n  private getPe(): number {\r\n    let value = 0;\r\n    for (let n = this.k; n <= this.m; n++) {\r\n      value += this.basicPn(n);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The expected number L of clients in the system\r\n  private getL(): number {\r\n    let sum1 = this.summation1ForL();\r\n    let sum2 = this.summation2ForL();\r\n    let sum3 = this.summation3ForL();\r\n    return sum1 + sum2 + sum3;\r\n  }\r\n\r\n  summation1ForL(): number {\r\n    let value = 0;\r\n    let end = this.k - 1;\r\n    for (let n = 0; n <= end; n++) {\r\n      // n*Pn\r\n      let operation = n * this.basicPn(n);\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  summation2ForL(): number {\r\n    let value = 0;\r\n    for (let n = this.k; n <= this.m; n++) {\r\n      // n - k\r\n      let item1 = n - this.k;\r\n      // Pn\r\n      let item2 = this.basicPn(n);\r\n      // (n - k) *Pn\r\n      let operation = item1 * item2;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  summation3ForL(): number {\r\n    let value = 0;\r\n    let end = this.k - 1;\r\n    for (let n = 0; n <= end; n++) {\r\n      value += this.basicPn(n);\r\n    }\r\n    // 1 - sum(Pn)\r\n    let item1 = 1 - value;\r\n    // k * (1 - sum(Pn))\r\n    return this.k * item1;\r\n  }\r\n\r\n  // The expected number Lq of clients in the queue\r\n  private getLq(): number {\r\n    let value = 0;\r\n    for (let n = this.k; n <= this.m; n++) {\r\n      // n - k\r\n      let item1 = n - this.k;\r\n      // Pn\r\n      let item2 = this.basicPn(n);\r\n      // (n - k) * Pn\r\n      let operation = item1 * item2;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The expected number Ln of clients in the non-empty queue\r\n  private getLn(): number {\r\n    return Division(this.lq, this.pe);\r\n  }\r\n\r\n  // The expected time Wq in the queue by the clients\r\n  private getWq(): number {\r\n    // (M - L) * lambda\r\n    let denominator = (this.m - this.l) * this.lambda;\r\n    return Division(this.lq, denominator);\r\n  }\r\n\r\n  // The expected average time W in the system by the clients\r\n  private getW(): number {\r\n    // 1 / miu\r\n    let item2 = Division(1, this.miu);\r\n    // Wq + (1 / miu)\r\n    return this.wq + item2;\r\n  }\r\n\r\n  // The expected time Wn in the queue for queues not empty by clients\r\n  private getWn(): number {\r\n    return Division(this.wq, this.pe);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}