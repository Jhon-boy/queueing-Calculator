{"ast":null,"code":"import { SystemOrQueuing, TypeCalculate } from '../Constants';\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\nexport class MM1MMModel {\n  // basic values\n  // results\n  constructor(lambda, miu, m, n = 0) {\n    this.lambda = void 0;\n    this.miu = void 0;\n    this.m = void 0;\n    this.n = void 0;\n    this.p0 = 0;\n    this.pe = 0;\n    this.pn = 0;\n    this.lq = 0;\n    this.l = 0;\n    this.wq = 0;\n    this.w = 0;\n    this.wn = 0;\n    this.ln = 0;\n    this.lambda = lambda;\n    this.miu = miu;\n    this.m = m;\n    this.n = n;\n  }\n\n  async calculateAll(system = SystemOrQueuing.System, typeCalculate = TypeCalculate.Fixed) {\n    this.p0 = this.getP0();\n    this.pe = 1 - this.p0;\n    this.pn = this.getPn(system, typeCalculate);\n    this.l = this.getL();\n    this.lq = this.getLq();\n    this.ln = this.getLn();\n    this.wq = this.getWq();\n    this.w = this.getW();\n    this.wn = this.getWn();\n  } // The probability P0 of finding the empty or idle system\n\n\n  getP0() {\n    let sum = this.summationForP0();\n    return Division(1, sum);\n  }\n\n  summationForP0() {\n    let value = 0;\n\n    for (let n = 0; n <= this.m; n++) {\n      // M!\n      let mFact = Factorial(this.m); // (M - n)!\n\n      let susFact = Factorial(this.m - n); // M!/(M - n)!\n\n      let item1 = Division(mFact, susFact); // (lambda/miu)^n\n\n      let item2 = Power(Division(this.lambda, this.miu), n);\n      let val = item1 * item2;\n      value += val;\n    }\n\n    return value;\n  } // The probability Pn of finding exactly n customers in the system\n\n\n  getPn(system, typeCalculate) {\n    // Calculate Pn to finding client on System\n    if (system === SystemOrQueuing.System) {\n      // fixed SYSTEM\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n);\n      } // max SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i); // console.log('MAX SYSTEM', value, i);\n        }\n\n        return value;\n      } // at least SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i < this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    } // Calculate Pn to finding client on Queuing\n\n\n    if (system === SystemOrQueuing.Queuing) {\n      // fixed Queuing\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n + 1);\n      } // max Queuing\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n        let end = this.n + 1;\n\n        for (let i = 0; i <= end; i++) {\n          value += this.basicPn(i);\n        }\n\n        return value;\n      } // at least Queuing\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    }\n\n    return 0;\n  }\n\n  basicPn(n) {\n    // M!\n    let mFact = Factorial(this.m); // (M - n)!\n\n    let susFact = Factorial(this.m - n); // M!/(M - n)!\n\n    let item1 = Division(mFact, susFact); // (lambda/miu)^n\n\n    let item2 = Power(Division(this.lambda, this.miu), n); // item1 * item2 * P0\n\n    return item1 * item2 * this.p0;\n  } // The expected number L of clients in the system\n\n\n  getL() {\n    // miu/lambda\n    let div = Division(this.miu, this.lambda); // 1 - P0\n\n    let sus = 1 - this.p0; // (miu/lambda)*(1 - P0)\n\n    let item2 = div * sus; // M - (miu/lambda)*(1 - P0)\n\n    return this.m - item2;\n  } // The expected number Lq of clients in the queue\n\n\n  getLq() {\n    // (lambda + miu)/lambda\n    let div = Division(this.lambda + this.miu, this.lambda); // 1 - P0\n\n    let sus = 1 - this.p0; // (miu/lambda)*(1 - P0)\n\n    let item2 = div * sus; // M - (miu/lambda)*(1 - P0)\n\n    return this.m - item2;\n  } // The expected number Ln of clients in the non-empty queue\n\n\n  getLn() {\n    // Lq/Pe\n    return Division(this.lq, this.pe);\n  } // The expected time Wq in the queue by the clients\n\n\n  getWq() {\n    // (M - L)lambda\n    let denominator = (this.m - this.l) * this.lambda; // Lq / (M - L)lambda\n\n    return Division(this.lq, denominator);\n  } // The expected average time W in the system by the clients\n\n\n  getW() {\n    // 1 / miu\n    let item2 = Division(1, this.miu); // Wq + (1 / miu)\n\n    return this.wq + item2;\n  } // The expected time Wn in the queue for queues not empty by clients\n\n\n  getWn() {\n    return Division(this.wq, this.pe);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jhonc/Desktop/CALCULADORA/queueing-theory-calculator/src/library/queueing/formulas/MM1MM.model.ts"],"names":["SystemOrQueuing","TypeCalculate","Division","Factorial","Power","MM1MMModel","constructor","lambda","miu","m","n","p0","pe","pn","lq","l","wq","w","wn","ln","calculateAll","system","System","typeCalculate","Fixed","getP0","getPn","getL","getLq","getLn","getWq","getW","getWn","sum","summationForP0","value","mFact","susFact","item1","item2","val","basicPn","Max","i","AtLeast","Queuing","end","div","sus","denominator"],"mappings":"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","sourcesContent":["import { SystemOrQueuing, TypeCalculate } from '../Constants';\r\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\r\n\r\nexport class MM1MMModel {\r\n  // basic values\r\n  readonly lambda: number;\r\n  readonly miu: number;\r\n  readonly m: number;\r\n  readonly n: number;\r\n  // results\r\n  p0: number = 0;\r\n  pe: number = 0;\r\n\r\n  pn: number = 0;\r\n  lq: number = 0;\r\n  l: number = 0;\r\n  wq: number = 0;\r\n  w: number = 0;\r\n  wn: number = 0;\r\n  ln: number = 0;\r\n\r\n  constructor(lambda: number, miu: number, m: number, n: number = 0) {\r\n    this.lambda = lambda;\r\n    this.miu = miu;\r\n    this.m = m;\r\n    this.n = n;\r\n  }\r\n\r\n  async calculateAll(\r\n    system: SystemOrQueuing = SystemOrQueuing.System,\r\n    typeCalculate: TypeCalculate = TypeCalculate.Fixed,\r\n  ): Promise<void> {\r\n    this.p0 = this.getP0();\r\n    this.pe = 1 - this.p0;\r\n    this.pn = this.getPn(system, typeCalculate);\r\n    this.l = this.getL();\r\n    this.lq = this.getLq();\r\n    this.ln = this.getLn();\r\n\r\n    this.wq = this.getWq();\r\n    this.w = this.getW();\r\n    this.wn = this.getWn();\r\n  }\r\n\r\n  // The probability P0 of finding the empty or idle system\r\n  private getP0(): number {\r\n    let sum = this.summationForP0();\r\n    return Division(1, sum);\r\n  }\r\n\r\n  private summationForP0(): number {\r\n    let value = 0;\r\n    for (let n = 0; n <= this.m; n++) {\r\n      // M!\r\n      let mFact = Factorial(this.m);\r\n      // (M - n)!\r\n      let susFact = Factorial(this.m - n);\r\n      // M!/(M - n)!\r\n      let item1 = Division(mFact, susFact);\r\n\r\n      // (lambda/miu)^n\r\n      let item2 = Power(Division(this.lambda, this.miu), n);\r\n      let val = item1 * item2;\r\n      value += val;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The probability Pn of finding exactly n customers in the system\r\n  private getPn(system: SystemOrQueuing, typeCalculate: TypeCalculate): number {\r\n    // Calculate Pn to finding client on System\r\n    if (system === SystemOrQueuing.System) {\r\n      // fixed SYSTEM\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n);\r\n      }\r\n\r\n      // max SYSTEM\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n          // console.log('MAX SYSTEM', value, i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least SYSTEM\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i < this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n    // Calculate Pn to finding client on Queuing\r\n    if (system === SystemOrQueuing.Queuing) {\r\n      // fixed Queuing\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n + 1);\r\n      }\r\n\r\n      // max Queuing\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        let end = this.n + 1;\r\n        for (let i = 0; i <= end; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least Queuing\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private basicPn(n: number): number {\r\n    // M!\r\n    let mFact = Factorial(this.m);\r\n    // (M - n)!\r\n    let susFact = Factorial(this.m - n);\r\n    // M!/(M - n)!\r\n    let item1 = Division(mFact, susFact);\r\n\r\n    // (lambda/miu)^n\r\n    let item2 = Power(Division(this.lambda, this.miu), n);\r\n\r\n    // item1 * item2 * P0\r\n    return item1 * item2 * this.p0;\r\n  }\r\n\r\n  // The expected number L of clients in the system\r\n  private getL(): number {\r\n    // miu/lambda\r\n    let div = Division(this.miu, this.lambda);\r\n    // 1 - P0\r\n    let sus = 1 - this.p0;\r\n    // (miu/lambda)*(1 - P0)\r\n    let item2 = div * sus;\r\n    // M - (miu/lambda)*(1 - P0)\r\n    return this.m - item2;\r\n  }\r\n\r\n  // The expected number Lq of clients in the queue\r\n  private getLq(): number {\r\n    // (lambda + miu)/lambda\r\n    let div = Division(this.lambda + this.miu, this.lambda);\r\n    // 1 - P0\r\n    let sus = 1 - this.p0;\r\n    // (miu/lambda)*(1 - P0)\r\n    let item2 = div * sus;\r\n    // M - (miu/lambda)*(1 - P0)\r\n    return this.m - item2;\r\n  }\r\n\r\n  // The expected number Ln of clients in the non-empty queue\r\n  private getLn(): number {\r\n    // Lq/Pe\r\n    return Division(this.lq, this.pe);\r\n  }\r\n\r\n  // The expected time Wq in the queue by the clients\r\n  private getWq(): number {\r\n    // (M - L)lambda\r\n    let denominator = (this.m - this.l) * this.lambda;\r\n    // Lq / (M - L)lambda\r\n    return Division(this.lq, denominator);\r\n  }\r\n\r\n  // The expected average time W in the system by the clients\r\n  private getW(): number {\r\n    // 1 / miu\r\n    let item2 = Division(1, this.miu);\r\n    // Wq + (1 / miu)\r\n    return this.wq + item2;\r\n  }\r\n\r\n  // The expected time Wn in the queue for queues not empty by clients\r\n  private getWn(): number {\r\n    return Division(this.wq, this.pe);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}