{"ast":null,"code":"import { SystemOrQueuing, TypeCalculate } from '../Constants';\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\nexport class MMKMMModel {\n  // basic values\n  // results\n  constructor(lambda, miu, k, m, n = 0) {\n    this.lambda = void 0;\n    this.miu = void 0;\n    this.m = void 0;\n    this.k = void 0;\n    this.n = void 0;\n    this.horas = void 0;\n    this.espera = void 0;\n    this.sistema = void 0;\n    this.servidor = void 0;\n    this.p0 = 0;\n    this.pe = 0;\n    this.pne = 0;\n    this.pn = 0;\n    this.lq = 0;\n    this.l = 0;\n    this.wq = 0;\n    this.w = 0;\n    this.wn = 0;\n    this.ln = 0;\n    this.lambda = lambda;\n    this.miu = miu;\n    this.k = k;\n    this.m = m;\n    this.n = n;\n  }\n\n  isMultichannel() {\n    return this.k > 1;\n  }\n\n  async calculateAll(system = SystemOrQueuing.System, typeCalculate = TypeCalculate.Fixed) {\n    this.p0 = this.getP0();\n    this.pn = this.getPn(system, typeCalculate);\n    this.pe = this.getPe();\n    this.pne = 1 - this.pe;\n    this.l = this.getL();\n    this.lq = this.getLq();\n    this.ln = this.getLn();\n    this.wq = this.getWq();\n    this.w = this.getW();\n    this.wn = this.getWn();\n  } // The probability P0 of finding the empty or idle system\n\n\n  getP0() {\n    // summation\n    let summation1 = this.summation1ForP0();\n    let summation2 = this.summation2ForP0();\n    return Division(1, summation1 + summation2);\n  }\n\n  summation1ForP0() {\n    let value = 0;\n\n    for (let n = 0; n <= parseInt(this.k.toString()) - 1; n++) {\n      // M!\n      let fact = Factorial(this.m); // (M - n)!\n\n      let subItem1 = Factorial(this.m - n); // n!\n\n      let subItem2 = Factorial(n); // (M - n)!n!\n\n      let denominator = subItem1 * subItem2; // M! / (M - n)!n!\n\n      let item1 = Division(fact, denominator); // (lambda/miu)^n\n\n      let div = Division(this.lambda, this.miu);\n      let item2 = Power(div, n);\n      let operation = item1 * item2;\n      value += operation;\n    }\n\n    return value;\n  }\n\n  summation2ForP0() {\n    let value = 0;\n\n    for (let n = this.k; n <= this.m; n++) {\n      // M!\n      let fact = Factorial(this.m); // (M - n)!\n\n      let subItem1 = Factorial(this.m - n); // k!\n\n      let subItem2 = Factorial(this.k); // k^n-k\n\n      let subItem3 = Power(this.k, n - this.k); // (M - n)!k!k^n-k\n\n      let denominator = subItem1 * subItem2 * subItem3; // M! / (M - n)!k!k^n-k\n\n      let item1 = Division(fact, denominator); // (lambda/miu)^n\n\n      let div = Division(this.lambda, this.miu);\n      let item2 = Power(div, n);\n      let operation = item1 * item2;\n      value += operation;\n    }\n\n    return value;\n  } // The probability Pn of finding exactly n customers in the system\n\n\n  getPn(system, typeCalculate) {\n    // Calculate Pn to finding client on System\n    if (system === SystemOrQueuing.System) {\n      // fixed SYSTEM\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n);\n      } // max SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i); // console.log('MAX SYSTEM', value, i);\n        }\n\n        return value;\n      } // at least SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i < this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    } // Calculate Pn to finding client on Queuing\n\n\n    if (system === SystemOrQueuing.Queuing) {\n      // fixed Queuing\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n + this.k);\n      } // max Queuing\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n        let end = this.n + this.k;\n\n        for (let i = 0; i <= end; i++) {\n          value += this.basicPn(i);\n        }\n\n        return value;\n      } // at least Queuing\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    }\n\n    return 0;\n  }\n\n  basicPn(n) {\n    if (0 <= n && n < this.k) {\n      return this.calculatePnWhenNLessK(n);\n    } else {\n      return this.calculatePnWhenNHigherK(n);\n    }\n  }\n\n  calculatePnWhenNLessK(n) {\n    // M!\n    let fact = Factorial(this.m); // (M - n)!\n\n    let subItem1 = Factorial(this.m - n); // n!\n\n    let subItem2 = Factorial(n); // (M - n)!n!\n\n    let denominator = subItem1 * subItem2; // M! / (M - n)!n!\n\n    let item1 = Division(fact, denominator); // (lambda/miu)^n\n\n    let div = Division(this.lambda, this.miu);\n    let item2 = Power(div, n);\n    return this.p0 * item1 * item2;\n  }\n\n  calculatePnWhenNHigherK(n) {\n    // M!\n    let fact = Factorial(this.m); // (M - n)!\n\n    let subItem1 = Factorial(this.m - n); // k!\n\n    let subItem2 = Factorial(this.k); // k^n-k\n\n    let subItem3 = Power(this.k, n - this.k); // (M - n)!k!k^n-k\n\n    let denominator = subItem1 * subItem2 * subItem3; // M! / (M - n)!k!k^n-k\n\n    let item1 = Division(fact, denominator); // (lambda/miu)^n\n\n    let div = Division(this.lambda, this.miu);\n    let item2 = Power(div, n);\n    return this.p0 * item1 * item2;\n  } // The probability Pe of finding the system busy\n\n\n  getPe() {\n    let value = 0;\n\n    for (let n = this.k; n <= this.m; n++) {\n      value += this.basicPn(n);\n    }\n\n    return value;\n  } // The expected number L of clients in the system\n\n\n  getL() {\n    let sum1 = this.summation1ForL();\n    let sum2 = this.summation2ForL();\n    let sum3 = this.summation3ForL();\n    return sum1 + sum2 + sum3;\n  }\n\n  summation1ForL() {\n    let value = 0;\n    let end = this.k - 1;\n\n    for (let n = 0; n <= end; n++) {\n      // n*Pn\n      let operation = n * this.basicPn(n);\n      value += operation;\n    }\n\n    return value;\n  }\n\n  summation2ForL() {\n    let value = 0;\n\n    for (let n = this.k; n <= this.m; n++) {\n      // n - k\n      let item1 = n - this.k; // Pn\n\n      let item2 = this.basicPn(n); // (n - k) *Pn\n\n      let operation = item1 * item2;\n      value += operation;\n    }\n\n    return value;\n  }\n\n  summation3ForL() {\n    let value = 0;\n    let end = this.k - 1;\n\n    for (let n = 0; n <= end; n++) {\n      value += this.basicPn(n);\n    } // 1 - sum(Pn)\n\n\n    let item1 = 1 - value; // k * (1 - sum(Pn))\n\n    return this.k * item1;\n  } // The expected number Lq of clients in the queue\n\n\n  getLq() {\n    let value = 0;\n\n    for (let n = this.k; n <= this.m; n++) {\n      // n - k\n      let item1 = n - this.k; // Pn\n\n      let item2 = this.basicPn(n); // (n - k) * Pn\n\n      let operation = item1 * item2;\n      value += operation;\n    }\n\n    return value;\n  } // The expected number Ln of clients in the non-empty queue\n\n\n  getLn() {\n    return Division(this.lq, this.pe);\n  } // The expected time Wq in the queue by the clients\n\n\n  getWq() {\n    // (M - L) * lambda\n    let denominator = (this.m - this.l) * this.lambda;\n    return Division(this.lq, denominator);\n  } // The expected average time W in the system by the clients\n\n\n  getW() {\n    // 1 / miu\n    let item2 = Division(1, this.miu); // Wq + (1 / miu)\n\n    return this.wq + item2;\n  } // The expected time Wn in the queue for queues not empty by clients\n\n\n  getWn() {\n    return Division(this.wq, this.pe);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jhonc/Desktop/CALCULADORA/queueing-theory-calculator/src/library/queueing/formulas/MMKMM.model.ts"],"names":["SystemOrQueuing","TypeCalculate","Division","Factorial","Power","MMKMMModel","constructor","lambda","miu","k","m","n","horas","espera","sistema","servidor","p0","pe","pne","pn","lq","l","wq","w","wn","ln","isMultichannel","calculateAll","system","System","typeCalculate","Fixed","getP0","getPn","getPe","getL","getLq","getLn","getWq","getW","getWn","summation1","summation1ForP0","summation2","summation2ForP0","value","parseInt","toString","fact","subItem1","subItem2","denominator","item1","div","item2","operation","subItem3","basicPn","Max","i","AtLeast","Queuing","end","calculatePnWhenNLessK","calculatePnWhenNHigherK","sum1","summation1ForL","sum2","summation2ForL","sum3","summation3ForL"],"mappings":"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","sourcesContent":["import { SystemOrQueuing, TypeCalculate } from '../Constants';\r\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\r\n\r\nexport class MMKMMModel {\r\n  // basic values\r\n  readonly lambda: number;\r\n  readonly miu: number;\r\n  readonly m: number;\r\n  readonly k: number;\r\n  readonly n: number;\r\n  readonly horas: number;\r\n  readonly espera: number;\r\n  readonly sistema: number;\r\n  readonly servidor: number;\r\n  \r\n  // results\r\n  p0: number = 0;\r\n  pe: number = 0;\r\n  pne: number = 0;\r\n\r\n  pn: number = 0;\r\n  lq: number = 0;\r\n  l: number = 0;\r\n  wq: number = 0;\r\n  w: number = 0;\r\n  wn: number = 0;\r\n  ln: number = 0;\r\n\r\n  constructor(\r\n    lambda: number,\r\n    miu: number,\r\n    k: number,\r\n    m: number,\r\n    n: number = 0,\r\n  ) {\r\n    this.lambda = lambda;\r\n    this.miu = miu;\r\n    this.k = k;\r\n    this.m = m;\r\n    this.n = n;\r\n  }\r\n\r\n  isMultichannel(): boolean {\r\n    return this.k > 1;\r\n  }\r\n\r\n  async calculateAll(\r\n    system: SystemOrQueuing = SystemOrQueuing.System,\r\n    typeCalculate: TypeCalculate = TypeCalculate.Fixed,\r\n  ): Promise<void> {\r\n    this.p0 = this.getP0();\r\n    this.pn = this.getPn(system, typeCalculate);\r\n    this.pe = this.getPe();\r\n    this.pne = 1 - this.pe;\r\n    this.l = this.getL();\r\n    this.lq = this.getLq();\r\n    this.ln = this.getLn();\r\n    this.wq = this.getWq();\r\n\r\n    this.w = this.getW();\r\n    this.wn = this.getWn();\r\n  }\r\n\r\n  // The probability P0 of finding the empty or idle system\r\n  private getP0(): number {\r\n    // summation\r\n    let summation1 = this.summation1ForP0();\r\n    let summation2 = this.summation2ForP0();\r\n\r\n    return Division(1, summation1 + summation2);\r\n  }\r\n\r\n  private summation1ForP0(): number {\r\n    let value = 0;\r\n    for (let n = 0; n <= parseInt(this.k.toString()) - 1; n++) {\r\n      // M!\r\n      let fact = Factorial(this.m);\r\n      // (M - n)!\r\n      let subItem1 = Factorial(this.m - n);\r\n      // n!\r\n      let subItem2 = Factorial(n);\r\n      // (M - n)!n!\r\n      let denominator = subItem1 * subItem2;\r\n      // M! / (M - n)!n!\r\n      let item1 = Division(fact, denominator);\r\n\r\n      // (lambda/miu)^n\r\n      let div = Division(this.lambda, this.miu);\r\n      let item2 = Power(div, n);\r\n\r\n      let operation = item1 * item2;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  private summation2ForP0(): number {\r\n    let value = 0;\r\n    for (let n = this.k; n <= this.m; n++) {\r\n      // M!\r\n      let fact = Factorial(this.m);\r\n      // (M - n)!\r\n      let subItem1 = Factorial(this.m - n);\r\n      // k!\r\n      let subItem2 = Factorial(this.k);\r\n      // k^n-k\r\n      let subItem3 = Power(this.k, n - this.k);\r\n      // (M - n)!k!k^n-k\r\n      let denominator = subItem1 * subItem2 * subItem3;\r\n      // M! / (M - n)!k!k^n-k\r\n      let item1 = Division(fact, denominator);\r\n\r\n      // (lambda/miu)^n\r\n      let div = Division(this.lambda, this.miu);\r\n      let item2 = Power(div, n);\r\n\r\n      let operation = item1 * item2;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The probability Pn of finding exactly n customers in the system\r\n  private getPn(system: SystemOrQueuing, typeCalculate: TypeCalculate): number {\r\n    // Calculate Pn to finding client on System\r\n    if (system === SystemOrQueuing.System) {\r\n      // fixed SYSTEM\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n);\r\n      }\r\n\r\n      // max SYSTEM\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n          // console.log('MAX SYSTEM', value, i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least SYSTEM\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i < this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n    // Calculate Pn to finding client on Queuing\r\n    if (system === SystemOrQueuing.Queuing) {\r\n      // fixed Queuing\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n + this.k);\r\n      }\r\n\r\n      // max Queuing\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        let end = this.n + this.k;\r\n        for (let i = 0; i <= end; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least Queuing\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  private basicPn(n: number): number {\r\n    if (0 <= n && n < this.k) {\r\n      return this.calculatePnWhenNLessK(n);\r\n    } else {\r\n      return this.calculatePnWhenNHigherK(n);\r\n    }\r\n  }\r\n\r\n  private calculatePnWhenNLessK(n: number): number {\r\n    // M!\r\n    let fact = Factorial(this.m);\r\n    // (M - n)!\r\n    let subItem1 = Factorial(this.m - n);\r\n    // n!\r\n    let subItem2 = Factorial(n);\r\n    // (M - n)!n!\r\n    let denominator = subItem1 * subItem2;\r\n    // M! / (M - n)!n!\r\n    let item1 = Division(fact, denominator);\r\n\r\n    // (lambda/miu)^n\r\n    let div = Division(this.lambda, this.miu);\r\n    let item2 = Power(div, n);\r\n\r\n    return this.p0 * item1 * item2;\r\n  }\r\n\r\n  private calculatePnWhenNHigherK(n: number): number {\r\n    // M!\r\n    let fact = Factorial(this.m);\r\n    // (M - n)!\r\n    let subItem1 = Factorial(this.m - n);\r\n    // k!\r\n    let subItem2 = Factorial(this.k);\r\n    // k^n-k\r\n    let subItem3 = Power(this.k, n - this.k);\r\n    // (M - n)!k!k^n-k\r\n    let denominator = subItem1 * subItem2 * subItem3;\r\n    // M! / (M - n)!k!k^n-k\r\n    let item1 = Division(fact, denominator);\r\n\r\n    // (lambda/miu)^n\r\n    let div = Division(this.lambda, this.miu);\r\n    let item2 = Power(div, n);\r\n\r\n    return this.p0 * item1 * item2;\r\n  }\r\n\r\n  // The probability Pe of finding the system busy\r\n  private getPe(): number {\r\n    let value = 0;\r\n    for (let n = this.k; n <= this.m; n++) {\r\n      value += this.basicPn(n);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The expected number L of clients in the system\r\n  private getL(): number {\r\n    let sum1 = this.summation1ForL();\r\n    let sum2 = this.summation2ForL();\r\n    let sum3 = this.summation3ForL();\r\n    return sum1 + sum2 + sum3;\r\n  }\r\n\r\n  summation1ForL(): number {\r\n    let value = 0;\r\n    let end = this.k - 1;\r\n    for (let n = 0; n <= end; n++) {\r\n      // n*Pn\r\n      let operation = n * this.basicPn(n);\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  summation2ForL(): number {\r\n    let value = 0;\r\n    for (let n = this.k; n <= this.m; n++) {\r\n      // n - k\r\n      let item1 = n - this.k;\r\n      // Pn\r\n      let item2 = this.basicPn(n);\r\n      // (n - k) *Pn\r\n      let operation = item1 * item2;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  summation3ForL(): number {\r\n    let value = 0;\r\n    let end = this.k - 1;\r\n    for (let n = 0; n <= end; n++) {\r\n      value += this.basicPn(n);\r\n    }\r\n    // 1 - sum(Pn)\r\n    let item1 = 1 - value;\r\n    // k * (1 - sum(Pn))\r\n    return this.k * item1;\r\n  }\r\n\r\n  // The expected number Lq of clients in the queue\r\n  private getLq(): number {\r\n    let value = 0;\r\n    for (let n = this.k; n <= this.m; n++) {\r\n      // n - k\r\n      let item1 = n - this.k;\r\n      // Pn\r\n      let item2 = this.basicPn(n);\r\n      // (n - k) * Pn\r\n      let operation = item1 * item2;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The expected number Ln of clients in the non-empty queue\r\n  private getLn(): number {\r\n    return Division(this.lq, this.pe);\r\n  }\r\n\r\n  // The expected time Wq in the queue by the clients\r\n  private getWq(): number {\r\n    // (M - L) * lambda\r\n    let denominator = (this.m - this.l) * this.lambda;\r\n    return Division(this.lq, denominator);\r\n  }\r\n\r\n  // The expected average time W in the system by the clients\r\n  private getW(): number {\r\n    // 1 / miu\r\n    let item2 = Division(1, this.miu);\r\n    // Wq + (1 / miu)\r\n    return this.wq + item2;\r\n  }\r\n\r\n  // The expected time Wn in the queue for queues not empty by clients\r\n  private getWn(): number {\r\n    return Division(this.wq, this.pe);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}