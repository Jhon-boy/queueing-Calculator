{"ast":null,"code":"import { SystemOrQueuing, TypeCalculate } from '../Constants';\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\nexport class MMKModel {\n  // basic values\n  // results\n  constructor(lambda, miu, k, n = 0, horas = 0, espera = 0, sistema = 0, servi) {\n    this.lambda = void 0;\n    this.miu = void 0;\n    this.k = void 0;\n    this.n = void 0;\n    this.horas = void 0;\n    this.espera = void 0;\n    this.sistema = void 0;\n    this.servidor = void 0;\n    this.p0 = 0;\n    this.pk = 0;\n    this.pne = 0;\n    this.pn = 0;\n    this.lq = 0;\n    this.l = 0;\n    this.wq = 0;\n    this.w = 0;\n    this.wn = 0;\n    this.ln = 0;\n    this.lambda = lambda;\n    this.miu = miu;\n    this.k = k;\n    this.n = n;\n  }\n\n  isMultichannel() {\n    return this.k > 1;\n  }\n\n  isStatable() {\n    let denominator = this.k * this.miu;\n    let condition = Division(this.lambda, denominator);\n    return condition < 1;\n  }\n\n  async calculateAll(system = SystemOrQueuing.System, typeCalculate = TypeCalculate.Fixed) {\n    this.p0 = this.getP0();\n    this.pk = this.getPk();\n    this.pne = 1 - this.pk;\n    this.pn = this.getPn(system, typeCalculate);\n    this.l = this.getL();\n    this.lq = this.getLq();\n    this.ln = this.getLn();\n    this.w = this.getW();\n    this.wq = this.getWq();\n    this.wn = this.getWn();\n  } // The probability P0 of finding the empty or idle system\n\n\n  getP0() {\n    // summation\n    let summation = this.summationForP0(); // (1/k!)\n\n    let fact = Factorial(this.k);\n    let subItem1 = Division(1, fact); // (lambda/miu)^k\n\n    let div = Division(this.lambda, this.miu);\n    let subItem2 = Power(div, this.k); // ((k*miu)/(k*miu-lambda))\n\n    let numerator = this.k * this.miu;\n    let denominator = this.k * this.miu - this.lambda;\n    let subItem3 = Division(numerator, denominator);\n    let item2 = subItem1 * subItem2 * subItem3;\n    return Division(1, summation + item2);\n  }\n\n  summationForP0() {\n    let value = 0;\n\n    for (let i = 0; i <= parseInt(this.k.toString()) - 1; i++) {\n      // (1/n!)\n      let fact = Factorial(i);\n      let item1 = Division(1, fact); // (lambda/miu)^n\n\n      let div = Division(this.lambda, this.miu);\n      let poten = Power(div, i);\n      let operation = item1 * poten;\n      value += operation;\n    }\n\n    return value;\n  } // The probability Pk that an arriving unit will have to wait\n\n\n  getPk() {\n    // (1/k!)\n    let item1 = Division(1, Factorial(this.k)); // (lambda/miu)^k\n\n    let item2 = Power(Division(this.lambda, this.miu), this.k); // ((k*miu)/(k*miu-lambda))\n\n    let numerator = this.k * this.miu;\n    let denominator = this.k * this.miu - this.lambda;\n    let item3 = Division(numerator, denominator); // item1*item2*item3*P0\n\n    return item1 * item2 * item3 * this.p0;\n  } // The probability Pn of finding exactly n customers in the system\n\n\n  getPn(system, typeCalculate) {\n    // Calculate Pn to finding client on System\n    if (system === SystemOrQueuing.System) {\n      // fixed SYSTEM\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n);\n      } // max SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i); // console.log('MAX SYSTEM', value, i);\n        }\n\n        return value;\n      } // at least SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i < this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    } // Calculate Pn to finding client on Queuing\n\n\n    if (system === SystemOrQueuing.Queuing) {\n      // fixed Queuing\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n + this.k);\n      } // max Queuing\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n        let end = this.n + this.k;\n\n        for (let i = 0; i <= end; i++) {\n          value += this.basicPn(i);\n        }\n\n        return value;\n      } // at least Queuing\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    }\n\n    return 0;\n  }\n\n  basicPn(n) {\n    if (n < this.k) {\n      return this.calculatePnWhenNLessK(n);\n    } else {\n      return this.calculatePnWhenNHigherK(n);\n    }\n  }\n\n  calculatePnWhenNLessK(n) {\n    // (P0/n!)\n    let item1 = Division(this.p0, Factorial(n)); // (lambda/miu)^n\n\n    let item2 = Power(Division(this.lambda, this.miu), n); // item1 * item2\n\n    return item1 * item2;\n  }\n\n  calculatePnWhenNHigherK(n) {\n    // (1/(k!(k)^n-k))\n    let fact = Factorial(this.k);\n    let pow = Power(this.k, n - this.k);\n    let item1 = Division(1, fact * pow); // (lambda/miu)^n\n\n    let item2 = Power(Division(this.lambda, this.miu), n); // item1*item2*P0\n\n    return item1 * item2 * this.p0;\n  } // The expected number L of clients in the system\n\n\n  getL() {\n    // (lambda/miu)\n    let lambdaDivMiu = Division(this.lambda, this.miu); // lambda*miu*((lambda/miu)^k)\n\n    let pow = Power(lambdaDivMiu, this.k);\n    let numerator = this.lambda * this.miu * pow; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    let subItem1 = Division(numerator, denominator); // subItem1*P0\n\n    let item1 = subItem1 * this.p0; // item1+(lambda/miu)\n\n    return item1 + lambdaDivMiu;\n  } // The expected number Lq of clients in the queue\n\n\n  getLq() {\n    // lambda*miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.lambda * this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    return Division(numerator, denominator);\n  } // The expected number Ln of clients in the non-empty queue\n\n\n  getLn() {\n    return Division(this.lq, this.pk);\n  } // The expected average time W in the system by the clients\n\n\n  getW() {\n    // miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    let item1 = Division(numerator, denominator); // (1/miu)\n\n    let item2 = Division(1, this.miu); // item1+item2\n\n    return item1 + item2;\n  } // The expected time Wq in the queue by the clients\n\n\n  getWq() {\n    // miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    return Division(numerator, denominator);\n  } // The expected time Wn in the queue for queues not empty by clients\n\n\n  getWn() {\n    return Division(this.wq, this.pk);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jhonc/Desktop/CALCULADORA/queueing-theory-calculator/src/library/queueing/formulas/MMK.model.ts"],"names":["SystemOrQueuing","TypeCalculate","Division","Factorial","Power","MMKModel","constructor","lambda","miu","k","n","horas","espera","sistema","servi","servidor","p0","pk","pne","pn","lq","l","wq","w","wn","ln","isMultichannel","isStatable","denominator","condition","calculateAll","system","System","typeCalculate","Fixed","getP0","getPk","getPn","getL","getLq","getLn","getW","getWq","getWn","summation","summationForP0","fact","subItem1","div","subItem2","numerator","subItem3","item2","value","i","parseInt","toString","item1","poten","operation","item3","basicPn","Max","AtLeast","Queuing","end","calculatePnWhenNLessK","calculatePnWhenNHigherK","pow","lambdaDivMiu","prod","square"],"mappings":"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","sourcesContent":["import { SystemOrQueuing, TypeCalculate } from '../Constants';\r\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\r\n\r\nexport class MMKModel {\r\n  // basic values\r\n  readonly lambda: number;\r\n  readonly miu: number;\r\n  readonly k: number;\r\n  readonly n: number;\r\n  readonly horas: number;\r\n  readonly espera: number;\r\n  readonly sistema: number;\r\n  readonly servidor: number;\r\n  // results\r\n  p0: number = 0;\r\n  pk: number = 0;\r\n  pne: number = 0;\r\n\r\n  pn: number = 0;\r\n  lq: number = 0;\r\n  l: number = 0;\r\n  wq: number = 0;\r\n  w: number = 0;\r\n  wn: number = 0;\r\n  ln: number = 0;\r\n\r\n  constructor(lambda: number, miu: number, k: number, n: number = 0, horas: number = 0, espera: number = 0, sistema: number = 0, servi) {\r\n    this.lambda = lambda;\r\n    this.miu = miu;\r\n    this.k = k;\r\n    this.n = n;\r\n  }\r\n\r\n  isMultichannel(): boolean {\r\n    return this.k > 1;\r\n  }\r\n\r\n  isStatable(): boolean {\r\n    let denominator = this.k * this.miu;\r\n    let condition = Division(this.lambda, denominator);\r\n    return condition < 1;\r\n  }\r\n\r\n  async calculateAll(\r\n    system: SystemOrQueuing = SystemOrQueuing.System,\r\n    typeCalculate: TypeCalculate = TypeCalculate.Fixed,\r\n  ): Promise<void> {\r\n    this.p0 = this.getP0();\r\n    this.pk = this.getPk();\r\n    this.pne = 1 - this.pk;\r\n    this.pn = this.getPn(system, typeCalculate);\r\n    this.l = this.getL();\r\n    this.lq = this.getLq();\r\n    this.ln = this.getLn();\r\n    this.w = this.getW();\r\n    this.wq = this.getWq();\r\n    this.wn = this.getWn();\r\n  }\r\n\r\n  // The probability P0 of finding the empty or idle system\r\n  private getP0(): number {\r\n    // summation\r\n    let summation = this.summationForP0();\r\n\r\n    // (1/k!)\r\n    let fact = Factorial(this.k);\r\n\r\n    let subItem1 = Division(1, fact);\r\n\r\n    // (lambda/miu)^k\r\n    let div = Division(this.lambda, this.miu);\r\n    let subItem2 = Power(div, this.k);\r\n\r\n    // ((k*miu)/(k*miu-lambda))\r\n    let numerator = this.k * this.miu;\r\n    let denominator = this.k * this.miu - this.lambda;\r\n    let subItem3 = Division(numerator, denominator);\r\n\r\n    let item2 = subItem1 * subItem2 * subItem3;\r\n\r\n    return Division(1, summation + item2);\r\n  }\r\n\r\n  private summationForP0(): number {\r\n    let value = 0;\r\n    for (let i = 0; i <= parseInt(this.k.toString()) - 1; i++) {\r\n      // (1/n!)\r\n      let fact = Factorial(i);\r\n      let item1 = Division(1, fact);\r\n\r\n      // (lambda/miu)^n\r\n      let div = Division(this.lambda, this.miu);\r\n      let poten = Power(div, i);\r\n\r\n      let operation = item1 * poten;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The probability Pk that an arriving unit will have to wait\r\n  private getPk(): number {\r\n    // (1/k!)\r\n    let item1 = Division(1, Factorial(this.k));\r\n\r\n    // (lambda/miu)^k\r\n    let item2 = Power(Division(this.lambda, this.miu), this.k);\r\n\r\n    // ((k*miu)/(k*miu-lambda))\r\n    let numerator = this.k * this.miu;\r\n    let denominator = this.k * this.miu - this.lambda;\r\n    let item3 = Division(numerator, denominator);\r\n\r\n    // item1*item2*item3*P0\r\n    return item1 * item2 * item3 * this.p0;\r\n  }\r\n\r\n  // The probability Pn of finding exactly n customers in the system\r\n  private getPn(system: SystemOrQueuing, typeCalculate: TypeCalculate): number {\r\n    // Calculate Pn to finding client on System\r\n    if (system === SystemOrQueuing.System) {\r\n      // fixed SYSTEM\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n);\r\n      }\r\n\r\n      // max SYSTEM\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n          // console.log('MAX SYSTEM', value, i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least SYSTEM\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i < this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n    // Calculate Pn to finding client on Queuing\r\n    if (system === SystemOrQueuing.Queuing) {\r\n      // fixed Queuing\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n + this.k);\r\n      }\r\n\r\n      // max Queuing\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        let end = this.n + this.k;\r\n        for (let i = 0; i <= end; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least Queuing\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  private basicPn(n: number): number {\r\n    if (n < this.k) {\r\n      return this.calculatePnWhenNLessK(n);\r\n    } else {\r\n      return this.calculatePnWhenNHigherK(n);\r\n    }\r\n  }\r\n\r\n  private calculatePnWhenNLessK(n: number): number {\r\n    // (P0/n!)\r\n    let item1 = Division(this.p0, Factorial(n));\r\n\r\n    // (lambda/miu)^n\r\n    let item2 = Power(Division(this.lambda, this.miu), n);\r\n\r\n    // item1 * item2\r\n    return item1 * item2;\r\n  }\r\n\r\n  private calculatePnWhenNHigherK(n: number): number {\r\n    // (1/(k!(k)^n-k))\r\n    let fact = Factorial(this.k);\r\n    let pow = Power(this.k, n - this.k);\r\n    let item1 = Division(1, fact * pow);\r\n\r\n    // (lambda/miu)^n\r\n    let item2 = Power(Division(this.lambda, this.miu), n);\r\n\r\n    // item1*item2*P0\r\n    return item1 * item2 * this.p0;\r\n  }\r\n\r\n  // The expected number L of clients in the system\r\n  private getL(): number {\r\n    // (lambda/miu)\r\n    let lambdaDivMiu = Division(this.lambda, this.miu);\r\n\r\n    // lambda*miu*((lambda/miu)^k)\r\n    let pow = Power(lambdaDivMiu, this.k);\r\n    let numerator = this.lambda * this.miu * pow;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    let subItem1 = Division(numerator, denominator);\r\n\r\n    // subItem1*P0\r\n    let item1 = subItem1 * this.p0;\r\n\r\n    // item1+(lambda/miu)\r\n    return item1 + lambdaDivMiu;\r\n  }\r\n\r\n  // The expected number Lq of clients in the queue\r\n  private getLq(): number {\r\n    // lambda*miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.lambda * this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    return Division(numerator, denominator);\r\n  }\r\n\r\n  // The expected number Ln of clients in the non-empty queue\r\n  private getLn(): number {\r\n    return Division(this.lq, this.pk);\r\n  }\r\n\r\n  // The expected average time W in the system by the clients\r\n  private getW(): number {\r\n    // miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    let item1 = Division(numerator, denominator);\r\n\r\n    // (1/miu)\r\n    let item2 = Division(1, this.miu);\r\n\r\n    // item1+item2\r\n    return item1 + item2;\r\n  }\r\n\r\n  // The expected time Wq in the queue by the clients\r\n  private getWq(): number {\r\n    // miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    return Division(numerator, denominator);\r\n  }\r\n\r\n  // The expected time Wn in the queue for queues not empty by clients\r\n  private getWn(): number {\r\n    return Division(this.wq, this.pk);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}