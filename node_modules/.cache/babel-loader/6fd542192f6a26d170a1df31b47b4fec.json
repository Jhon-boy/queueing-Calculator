{"ast":null,"code":"import { SystemOrQueuing, TypeCalculate } from '../Constants';\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\nexport class MMKModel {\n  // basic values\n  // results\n  constructor(lambda, miu, k, n = 0, horas = 0, espera = 0, sistema = 0, servidor = 0) {\n    this.lambda = void 0;\n    this.miu = void 0;\n    this.k = void 0;\n    this.n = void 0;\n    this.horas = void 0;\n    this.espera = void 0;\n    this.sistema = void 0;\n    this.servidor = void 0;\n    this.p0 = 0;\n    this.pk = 0;\n    this.pne = 0;\n    this.pn = 0;\n    this.lq = 0;\n    this.l = 0;\n    this.wq = 0;\n    this.w = 0;\n    this.wn = 0;\n    this.ln = 0;\n    this.costoServidor = 0;\n    this.costo = void 0;\n    this.lambda = lambda;\n    this.miu = miu;\n    this.k = k;\n    this.n = n;\n    this.horas = horas;\n    this.espera = espera;\n    this.sistema = sistema;\n    this.servidor = servidor;\n  }\n\n  isMultichannel() {\n    return this.k > 1;\n  }\n\n  isStatable() {\n    let denominator = this.k * this.miu;\n    let condition = Division(this.lambda, denominator);\n    return condition < 1;\n  }\n\n  async calculateAll(system = SystemOrQueuing.System, typeCalculate = TypeCalculate.Fixed) {\n    this.p0 = this.getP0();\n    this.pk = this.getPk();\n    this.pne = 1 - this.pk;\n    this.pn = this.getPn(system, typeCalculate);\n    this.l = this.getL();\n    this.lq = this.getLq();\n    this.ln = this.getLn();\n    this.w = this.getW();\n    this.wq = this.getWq();\n    this.wn = this.getWn();\n  } // The probability P0 of finding the empty or idle system\n\n\n  getP0() {\n    // summation\n    let summation = this.summationForP0(); // (1/k!)\n\n    let fact = Factorial(this.k);\n    let subItem1 = Division(1, fact); // (lambda/miu)^k\n\n    let div = Division(this.lambda, this.miu);\n    let subItem2 = Power(div, this.k); // ((k*miu)/(k*miu-lambda))\n\n    let numerator = this.k * this.miu;\n    let denominator = this.k * this.miu - this.lambda;\n    let subItem3 = Division(numerator, denominator);\n    let item2 = subItem1 * subItem2 * subItem3;\n    return Division(1, summation + item2);\n  }\n\n  summationForP0() {\n    let value = 0;\n\n    for (let i = 0; i <= parseInt(this.k.toString()) - 1; i++) {\n      // (1/n!)\n      let fact = Factorial(i);\n      let item1 = Division(1, fact); // (lambda/miu)^n\n\n      let div = Division(this.lambda, this.miu);\n      let poten = Power(div, i);\n      let operation = item1 * poten;\n      value += operation;\n    }\n\n    return value;\n  } // The probability Pk that an arriving unit will have to wait\n\n\n  getPk() {\n    // (1/k!)\n    let item1 = Division(1, Factorial(this.k)); // (lambda/miu)^k\n\n    let item2 = Power(Division(this.lambda, this.miu), this.k); // ((k*miu)/(k*miu-lambda))\n\n    let numerator = this.k * this.miu;\n    let denominator = this.k * this.miu - this.lambda;\n    let item3 = Division(numerator, denominator); // item1*item2*item3*P0\n\n    return item1 * item2 * item3 * this.p0;\n  } // The probability Pn of finding exactly n customers in the system\n\n\n  getPn(system, typeCalculate) {\n    // Calculate Pn to finding client on System\n    if (system === SystemOrQueuing.System) {\n      // fixed SYSTEM\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n);\n      } // max SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i); // console.log('MAX SYSTEM', value, i);\n        }\n\n        return value;\n      } // at least SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i < this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    } // Calculate Pn to finding client on Queuing\n\n\n    if (system === SystemOrQueuing.Queuing) {\n      // fixed Queuing\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n + this.k);\n      } // max Queuing\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n        let end = this.n + this.k;\n\n        for (let i = 0; i <= end; i++) {\n          value += this.basicPn(i);\n        }\n\n        return value;\n      } // at least Queuing\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    }\n\n    return 0;\n  }\n\n  basicPn(n) {\n    if (n < this.k) {\n      return this.calculatePnWhenNLessK(n);\n    } else {\n      return this.calculatePnWhenNHigherK(n);\n    }\n  }\n\n  calculatePnWhenNLessK(n) {\n    // (P0/n!)\n    let item1 = Division(this.p0, Factorial(n)); // (lambda/miu)^n\n\n    let item2 = Power(Division(this.lambda, this.miu), n); // item1 * item2\n\n    return item1 * item2;\n  }\n\n  calculatePnWhenNHigherK(n) {\n    // (1/(k!(k)^n-k))\n    let fact = Factorial(this.k);\n    let pow = Power(this.k, n - this.k);\n    let item1 = Division(1, fact * pow); // (lambda/miu)^n\n\n    let item2 = Power(Division(this.lambda, this.miu), n); // item1*item2*P0\n\n    return item1 * item2 * this.p0;\n  } // The expected number L of clients in the system\n\n\n  getL() {\n    // (lambda/miu)\n    let lambdaDivMiu = Division(this.lambda, this.miu); // lambda*miu*((lambda/miu)^k)\n\n    let pow = Power(lambdaDivMiu, this.k);\n    let numerator = this.lambda * this.miu * pow; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    let subItem1 = Division(numerator, denominator); // subItem1*P0\n\n    let item1 = subItem1 * this.p0; // item1+(lambda/miu)\n\n    return item1 + lambdaDivMiu;\n  } // The expected number Lq of clients in the queue\n\n\n  getLq() {\n    // lambda*miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.lambda * this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    return Division(numerator, denominator);\n  } // The expected number Ln of clients in the non-empty queue\n\n\n  getLn() {\n    return Division(this.lq, this.pk);\n  } // The expected average time W in the system by the clients\n\n\n  getW() {\n    // miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    let item1 = Division(numerator, denominator); // (1/miu)\n\n    let item2 = Division(1, this.miu); // item1+item2\n\n    return item1 + item2;\n  } // The expected time Wq in the queue by the clients\n\n\n  getWq() {\n    // miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    return Division(numerator, denominator);\n  } // The expected time Wn in the queue for queues not empty by clients\n\n\n  getWn() {\n    return Division(this.wq, this.pk);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jhonc/Desktop/CALCULADORA/queueing-theory-calculator/src/library/queueing/formulas/MMK.model.ts"],"names":["SystemOrQueuing","TypeCalculate","Division","Factorial","Power","MMKModel","constructor","lambda","miu","k","n","horas","espera","sistema","servidor","p0","pk","pne","pn","lq","l","wq","w","wn","ln","costoServidor","costo","isMultichannel","isStatable","denominator","condition","calculateAll","system","System","typeCalculate","Fixed","getP0","getPk","getPn","getL","getLq","getLn","getW","getWq","getWn","summation","summationForP0","fact","subItem1","div","subItem2","numerator","subItem3","item2","value","i","parseInt","toString","item1","poten","operation","item3","basicPn","Max","AtLeast","Queuing","end","calculatePnWhenNLessK","calculatePnWhenNHigherK","pow","lambdaDivMiu","prod","square"],"mappings":"AAAA,SAASA,eAAT,EAA0BC,aAA1B,QAA+C,cAA/C;AACA,SAASC,QAAT,EAAmBC,SAAnB,EAA8BC,KAA9B,QAA2C,4BAA3C;AAEA,OAAO,MAAMC,QAAN,CAAe;AACpB;AASA;AAeAC,EAAAA,WAAW,CAACC,MAAD,EAAiBC,GAAjB,EAA8BC,CAA9B,EAAyCC,CAAS,GAAG,CAArD,EAAwDC,KAAa,GAAG,CAAxE,EAA2EC,MAAc,GAAG,CAA5F,EAA+FC,OAAe,GAAG,CAAjH,EAAoHC,QAAgB,GAAG,CAAvI,EAA0I;AAAA,SAvB5IP,MAuB4I;AAAA,SAtB5IC,GAsB4I;AAAA,SArB5IC,CAqB4I;AAAA,SApB5IC,CAoB4I;AAAA,SAnB5IC,KAmB4I;AAAA,SAlB5IC,MAkB4I;AAAA,SAjB5IC,OAiB4I;AAAA,SAhB5IC,QAgB4I;AAAA,SAdrJC,EAcqJ,GAdxI,CAcwI;AAAA,SAbrJC,EAaqJ,GAbxI,CAawI;AAAA,SAZrJC,GAYqJ,GAZvI,CAYuI;AAAA,SAVrJC,EAUqJ,GAVxI,CAUwI;AAAA,SATrJC,EASqJ,GATxI,CASwI;AAAA,SARrJC,CAQqJ,GARzI,CAQyI;AAAA,SAPrJC,EAOqJ,GAPxI,CAOwI;AAAA,SANrJC,CAMqJ,GANzI,CAMyI;AAAA,SALrJC,EAKqJ,GALxI,CAKwI;AAAA,SAJrJC,EAIqJ,GAJxI,CAIwI;AAAA,SAHrJC,aAGqJ,GAHtI,CAGsI;AAAA,SAFrJC,KAEqJ;AACnJ,SAAKnB,MAAL,GAAcA,MAAd;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACD;;AAEDa,EAAAA,cAAc,GAAY;AACxB,WAAO,KAAKlB,CAAL,GAAS,CAAhB;AACD;;AAEDmB,EAAAA,UAAU,GAAY;AACpB,QAAIC,WAAW,GAAG,KAAKpB,CAAL,GAAS,KAAKD,GAAhC;AACA,QAAIsB,SAAS,GAAG5B,QAAQ,CAAC,KAAKK,MAAN,EAAcsB,WAAd,CAAxB;AACA,WAAOC,SAAS,GAAG,CAAnB;AACD;;AAEiB,QAAZC,YAAY,CAChBC,MAAuB,GAAGhC,eAAe,CAACiC,MAD1B,EAEhBC,aAA4B,GAAGjC,aAAa,CAACkC,KAF7B,EAGD;AACf,SAAKpB,EAAL,GAAU,KAAKqB,KAAL,EAAV;AACA,SAAKpB,EAAL,GAAU,KAAKqB,KAAL,EAAV;AACA,SAAKpB,GAAL,GAAW,IAAI,KAAKD,EAApB;AACA,SAAKE,EAAL,GAAU,KAAKoB,KAAL,CAAWN,MAAX,EAAmBE,aAAnB,CAAV;AACA,SAAKd,CAAL,GAAS,KAAKmB,IAAL,EAAT;AACA,SAAKpB,EAAL,GAAU,KAAKqB,KAAL,EAAV;AACA,SAAKhB,EAAL,GAAU,KAAKiB,KAAL,EAAV;AACA,SAAKnB,CAAL,GAAS,KAAKoB,IAAL,EAAT;AACA,SAAKrB,EAAL,GAAU,KAAKsB,KAAL,EAAV;AACA,SAAKpB,EAAL,GAAU,KAAKqB,KAAL,EAAV;AACD,GA5DmB,CA8DpB;;;AACQR,EAAAA,KAAK,GAAW;AACtB;AACA,QAAIS,SAAS,GAAG,KAAKC,cAAL,EAAhB,CAFsB,CAItB;;AACA,QAAIC,IAAI,GAAG5C,SAAS,CAAC,KAAKM,CAAN,CAApB;AAEA,QAAIuC,QAAQ,GAAG9C,QAAQ,CAAC,CAAD,EAAI6C,IAAJ,CAAvB,CAPsB,CAStB;;AACA,QAAIE,GAAG,GAAG/C,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAlB;AACA,QAAI0C,QAAQ,GAAG9C,KAAK,CAAC6C,GAAD,EAAM,KAAKxC,CAAX,CAApB,CAXsB,CAatB;;AACA,QAAI0C,SAAS,GAAG,KAAK1C,CAAL,GAAS,KAAKD,GAA9B;AACA,QAAIqB,WAAW,GAAG,KAAKpB,CAAL,GAAS,KAAKD,GAAd,GAAoB,KAAKD,MAA3C;AACA,QAAI6C,QAAQ,GAAGlD,QAAQ,CAACiD,SAAD,EAAYtB,WAAZ,CAAvB;AAEA,QAAIwB,KAAK,GAAGL,QAAQ,GAAGE,QAAX,GAAsBE,QAAlC;AAEA,WAAOlD,QAAQ,CAAC,CAAD,EAAI2C,SAAS,GAAGQ,KAAhB,CAAf;AACD;;AAEOP,EAAAA,cAAc,GAAW;AAC/B,QAAIQ,KAAK,GAAG,CAAZ;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIC,QAAQ,CAAC,KAAK/C,CAAL,CAAOgD,QAAP,EAAD,CAAR,GAA8B,CAAnD,EAAsDF,CAAC,EAAvD,EAA2D;AACzD;AACA,UAAIR,IAAI,GAAG5C,SAAS,CAACoD,CAAD,CAApB;AACA,UAAIG,KAAK,GAAGxD,QAAQ,CAAC,CAAD,EAAI6C,IAAJ,CAApB,CAHyD,CAKzD;;AACA,UAAIE,GAAG,GAAG/C,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAlB;AACA,UAAImD,KAAK,GAAGvD,KAAK,CAAC6C,GAAD,EAAMM,CAAN,CAAjB;AAEA,UAAIK,SAAS,GAAGF,KAAK,GAAGC,KAAxB;AACAL,MAAAA,KAAK,IAAIM,SAAT;AACD;;AACD,WAAON,KAAP;AACD,GArGmB,CAuGpB;;;AACQjB,EAAAA,KAAK,GAAW;AACtB;AACA,QAAIqB,KAAK,GAAGxD,QAAQ,CAAC,CAAD,EAAIC,SAAS,CAAC,KAAKM,CAAN,CAAb,CAApB,CAFsB,CAItB;;AACA,QAAI4C,KAAK,GAAGjD,KAAK,CAACF,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAT,EAAkC,KAAKC,CAAvC,CAAjB,CALsB,CAOtB;;AACA,QAAI0C,SAAS,GAAG,KAAK1C,CAAL,GAAS,KAAKD,GAA9B;AACA,QAAIqB,WAAW,GAAG,KAAKpB,CAAL,GAAS,KAAKD,GAAd,GAAoB,KAAKD,MAA3C;AACA,QAAIsD,KAAK,GAAG3D,QAAQ,CAACiD,SAAD,EAAYtB,WAAZ,CAApB,CAVsB,CAYtB;;AACA,WAAO6B,KAAK,GAAGL,KAAR,GAAgBQ,KAAhB,GAAwB,KAAK9C,EAApC;AACD,GAtHmB,CAwHpB;;;AACQuB,EAAAA,KAAK,CAACN,MAAD,EAA0BE,aAA1B,EAAgE;AAC3E;AACA,QAAIF,MAAM,KAAKhC,eAAe,CAACiC,MAA/B,EAAuC;AACrC;AACA,UAAIC,aAAa,KAAKjC,aAAa,CAACkC,KAApC,EAA2C;AACzC,eAAO,KAAK2B,OAAL,CAAa,KAAKpD,CAAlB,CAAP;AACD,OAJoC,CAMrC;;;AACA,UAAIwB,aAAa,KAAKjC,aAAa,CAAC8D,GAApC,EAAyC;AACvC,YAAIT,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,KAAK7C,CAA1B,EAA6B6C,CAAC,EAA9B,EAAkC;AAChCD,UAAAA,KAAK,IAAI,KAAKQ,OAAL,CAAaP,CAAb,CAAT,CADgC,CAEhC;AACD;;AACD,eAAOD,KAAP;AACD,OAdoC,CAgBrC;;;AACA,UAAIpB,aAAa,KAAKjC,aAAa,CAAC+D,OAApC,EAA6C;AAC3C,YAAIV,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK7C,CAAzB,EAA4B6C,CAAC,EAA7B,EAAiC;AAC/BD,UAAAA,KAAK,IAAI,KAAKQ,OAAL,CAAaP,CAAb,CAAT;AACD;;AACD,eAAO,IAAID,KAAX;AACD;AACF,KA1B0E,CA2B3E;;;AACA,QAAItB,MAAM,KAAKhC,eAAe,CAACiE,OAA/B,EAAwC;AACtC;AACA,UAAI/B,aAAa,KAAKjC,aAAa,CAACkC,KAApC,EAA2C;AACzC,eAAO,KAAK2B,OAAL,CAAa,KAAKpD,CAAL,GAAS,KAAKD,CAA3B,CAAP;AACD,OAJqC,CAMtC;;;AACA,UAAIyB,aAAa,KAAKjC,aAAa,CAAC8D,GAApC,EAAyC;AACvC,YAAIT,KAAK,GAAG,CAAZ;AACA,YAAIY,GAAG,GAAG,KAAKxD,CAAL,GAAS,KAAKD,CAAxB;;AACA,aAAK,IAAI8C,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIW,GAArB,EAA0BX,CAAC,EAA3B,EAA+B;AAC7BD,UAAAA,KAAK,IAAI,KAAKQ,OAAL,CAAaP,CAAb,CAAT;AACD;;AACD,eAAOD,KAAP;AACD,OAdqC,CAgBtC;;;AACA,UAAIpB,aAAa,KAAKjC,aAAa,CAAC+D,OAApC,EAA6C;AAC3C,YAAIV,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,KAAK7C,CAA1B,EAA6B6C,CAAC,EAA9B,EAAkC;AAChCD,UAAAA,KAAK,IAAI,KAAKQ,OAAL,CAAaP,CAAb,CAAT;AACD;;AACD,eAAO,IAAID,KAAX;AACD;AACF;;AAED,WAAO,CAAP;AACD;;AAEOQ,EAAAA,OAAO,CAACpD,CAAD,EAAoB;AACjC,QAAIA,CAAC,GAAG,KAAKD,CAAb,EAAgB;AACd,aAAO,KAAK0D,qBAAL,CAA2BzD,CAA3B,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAK0D,uBAAL,CAA6B1D,CAA7B,CAAP;AACD;AACF;;AAEOyD,EAAAA,qBAAqB,CAACzD,CAAD,EAAoB;AAC/C;AACA,QAAIgD,KAAK,GAAGxD,QAAQ,CAAC,KAAKa,EAAN,EAAUZ,SAAS,CAACO,CAAD,CAAnB,CAApB,CAF+C,CAI/C;;AACA,QAAI2C,KAAK,GAAGjD,KAAK,CAACF,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAT,EAAkCE,CAAlC,CAAjB,CAL+C,CAO/C;;AACA,WAAOgD,KAAK,GAAGL,KAAf;AACD;;AAEOe,EAAAA,uBAAuB,CAAC1D,CAAD,EAAoB;AACjD;AACA,QAAIqC,IAAI,GAAG5C,SAAS,CAAC,KAAKM,CAAN,CAApB;AACA,QAAI4D,GAAG,GAAGjE,KAAK,CAAC,KAAKK,CAAN,EAASC,CAAC,GAAG,KAAKD,CAAlB,CAAf;AACA,QAAIiD,KAAK,GAAGxD,QAAQ,CAAC,CAAD,EAAI6C,IAAI,GAAGsB,GAAX,CAApB,CAJiD,CAMjD;;AACA,QAAIhB,KAAK,GAAGjD,KAAK,CAACF,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAT,EAAkCE,CAAlC,CAAjB,CAPiD,CASjD;;AACA,WAAOgD,KAAK,GAAGL,KAAR,GAAgB,KAAKtC,EAA5B;AACD,GAhNmB,CAkNpB;;;AACQwB,EAAAA,IAAI,GAAW;AACrB;AACA,QAAI+B,YAAY,GAAGpE,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAA3B,CAFqB,CAIrB;;AACA,QAAI6D,GAAG,GAAGjE,KAAK,CAACkE,YAAD,EAAe,KAAK7D,CAApB,CAAf;AACA,QAAI0C,SAAS,GAAG,KAAK5C,MAAL,GAAc,KAAKC,GAAnB,GAAyB6D,GAAzC,CANqB,CAOrB;;AACA,QAAItB,IAAI,GAAG5C,SAAS,CAAC,KAAKM,CAAL,GAAS,CAAV,CAApB;AACA,QAAI8D,IAAI,GAAG,KAAK9D,CAAL,GAAS,KAAKD,GAAd,GAAoB,KAAKD,MAApC;AACA,QAAIiE,MAAM,GAAGpE,KAAK,CAACmE,IAAD,EAAO,CAAP,CAAlB;AACA,QAAI1C,WAAW,GAAGkB,IAAI,GAAGyB,MAAzB,CAXqB,CAYrB;;AACA,QAAIxB,QAAQ,GAAG9C,QAAQ,CAACiD,SAAD,EAAYtB,WAAZ,CAAvB,CAbqB,CAerB;;AACA,QAAI6B,KAAK,GAAGV,QAAQ,GAAG,KAAKjC,EAA5B,CAhBqB,CAkBrB;;AACA,WAAO2C,KAAK,GAAGY,YAAf;AACD,GAvOmB,CAyOpB;;;AACQ9B,EAAAA,KAAK,GAAW;AACtB;AACA,QAAI6B,GAAG,GAAGjE,KAAK,CAACF,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAT,EAAkC,KAAKC,CAAvC,CAAf;AACA,QAAI0C,SAAS,GAAG,KAAK5C,MAAL,GAAc,KAAKC,GAAnB,GAAyB6D,GAAzB,GAA+B,KAAKtD,EAApD,CAHsB,CAItB;;AACA,QAAIgC,IAAI,GAAG5C,SAAS,CAAC,KAAKM,CAAL,GAAS,CAAV,CAApB;AACA,QAAI8D,IAAI,GAAG,KAAK9D,CAAL,GAAS,KAAKD,GAAd,GAAoB,KAAKD,MAApC;AACA,QAAIiE,MAAM,GAAGpE,KAAK,CAACmE,IAAD,EAAO,CAAP,CAAlB;AACA,QAAI1C,WAAW,GAAGkB,IAAI,GAAGyB,MAAzB,CARsB,CAStB;;AACA,WAAOtE,QAAQ,CAACiD,SAAD,EAAYtB,WAAZ,CAAf;AACD,GArPmB,CAuPpB;;;AACQY,EAAAA,KAAK,GAAW;AACtB,WAAOvC,QAAQ,CAAC,KAAKiB,EAAN,EAAU,KAAKH,EAAf,CAAf;AACD,GA1PmB,CA4PpB;;;AACQ0B,EAAAA,IAAI,GAAW;AACrB;AACA,QAAI2B,GAAG,GAAGjE,KAAK,CAACF,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAT,EAAkC,KAAKC,CAAvC,CAAf;AACA,QAAI0C,SAAS,GAAG,KAAK3C,GAAL,GAAW6D,GAAX,GAAiB,KAAKtD,EAAtC,CAHqB,CAIrB;;AACA,QAAIgC,IAAI,GAAG5C,SAAS,CAAC,KAAKM,CAAL,GAAS,CAAV,CAApB;AACA,QAAI8D,IAAI,GAAG,KAAK9D,CAAL,GAAS,KAAKD,GAAd,GAAoB,KAAKD,MAApC;AACA,QAAIiE,MAAM,GAAGpE,KAAK,CAACmE,IAAD,EAAO,CAAP,CAAlB;AACA,QAAI1C,WAAW,GAAGkB,IAAI,GAAGyB,MAAzB,CARqB,CASrB;;AACA,QAAId,KAAK,GAAGxD,QAAQ,CAACiD,SAAD,EAAYtB,WAAZ,CAApB,CAVqB,CAYrB;;AACA,QAAIwB,KAAK,GAAGnD,QAAQ,CAAC,CAAD,EAAI,KAAKM,GAAT,CAApB,CAbqB,CAerB;;AACA,WAAOkD,KAAK,GAAGL,KAAf;AACD,GA9QmB,CAgRpB;;;AACQV,EAAAA,KAAK,GAAW;AACtB;AACA,QAAI0B,GAAG,GAAGjE,KAAK,CAACF,QAAQ,CAAC,KAAKK,MAAN,EAAc,KAAKC,GAAnB,CAAT,EAAkC,KAAKC,CAAvC,CAAf;AACA,QAAI0C,SAAS,GAAG,KAAK3C,GAAL,GAAW6D,GAAX,GAAiB,KAAKtD,EAAtC,CAHsB,CAItB;;AACA,QAAIgC,IAAI,GAAG5C,SAAS,CAAC,KAAKM,CAAL,GAAS,CAAV,CAApB;AACA,QAAI8D,IAAI,GAAG,KAAK9D,CAAL,GAAS,KAAKD,GAAd,GAAoB,KAAKD,MAApC;AACA,QAAIiE,MAAM,GAAGpE,KAAK,CAACmE,IAAD,EAAO,CAAP,CAAlB;AACA,QAAI1C,WAAW,GAAGkB,IAAI,GAAGyB,MAAzB,CARsB,CAStB;;AACA,WAAOtE,QAAQ,CAACiD,SAAD,EAAYtB,WAAZ,CAAf;AACD,GA5RmB,CA8RpB;;;AACQe,EAAAA,KAAK,GAAW;AACtB,WAAO1C,QAAQ,CAAC,KAAKmB,EAAN,EAAU,KAAKL,EAAf,CAAf;AACD;;AAjSmB","sourcesContent":["import { SystemOrQueuing, TypeCalculate } from '../Constants';\r\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\r\n\r\nexport class MMKModel {\r\n  // basic values\r\n  readonly lambda: number;\r\n  readonly miu: number;\r\n  readonly k: number;\r\n  readonly n: number;\r\n  readonly horas: number;\r\n  readonly espera: number;\r\n  readonly sistema: number;\r\n  readonly servidor: number;\r\n  // results\r\n  p0: number = 0;\r\n  pk: number = 0;\r\n  pne: number = 0;\r\n\r\n  pn: number = 0;\r\n  lq: number = 0;\r\n  l: number = 0;\r\n  wq: number = 0;\r\n  w: number = 0;\r\n  wn: number = 0;\r\n  ln: number = 0;\r\n  costoServidor =0;\r\n  costo\r\n\r\n  constructor(lambda: number, miu: number, k: number, n: number = 0, horas: number = 0, espera: number = 0, sistema: number = 0, servidor: number = 0) {\r\n    this.lambda = lambda;\r\n    this.miu = miu;\r\n    this.k = k;\r\n    this.n = n;\r\n    this.horas = horas;\r\n    this.espera = espera;\r\n    this.sistema = sistema;\r\n    this.servidor = servidor;\r\n  }\r\n\r\n  isMultichannel(): boolean {\r\n    return this.k > 1;\r\n  }\r\n\r\n  isStatable(): boolean {\r\n    let denominator = this.k * this.miu;\r\n    let condition = Division(this.lambda, denominator);\r\n    return condition < 1;\r\n  }\r\n\r\n  async calculateAll(\r\n    system: SystemOrQueuing = SystemOrQueuing.System,\r\n    typeCalculate: TypeCalculate = TypeCalculate.Fixed,\r\n  ): Promise<void> {\r\n    this.p0 = this.getP0();\r\n    this.pk = this.getPk();\r\n    this.pne = 1 - this.pk;\r\n    this.pn = this.getPn(system, typeCalculate);\r\n    this.l = this.getL();\r\n    this.lq = this.getLq();\r\n    this.ln = this.getLn();\r\n    this.w = this.getW();\r\n    this.wq = this.getWq();\r\n    this.wn = this.getWn();\r\n  }\r\n\r\n  // The probability P0 of finding the empty or idle system\r\n  private getP0(): number {\r\n    // summation\r\n    let summation = this.summationForP0();\r\n\r\n    // (1/k!)\r\n    let fact = Factorial(this.k);\r\n\r\n    let subItem1 = Division(1, fact);\r\n\r\n    // (lambda/miu)^k\r\n    let div = Division(this.lambda, this.miu);\r\n    let subItem2 = Power(div, this.k);\r\n\r\n    // ((k*miu)/(k*miu-lambda))\r\n    let numerator = this.k * this.miu;\r\n    let denominator = this.k * this.miu - this.lambda;\r\n    let subItem3 = Division(numerator, denominator);\r\n\r\n    let item2 = subItem1 * subItem2 * subItem3;\r\n\r\n    return Division(1, summation + item2);\r\n  }\r\n\r\n  private summationForP0(): number {\r\n    let value = 0;\r\n    for (let i = 0; i <= parseInt(this.k.toString()) - 1; i++) {\r\n      // (1/n!)\r\n      let fact = Factorial(i);\r\n      let item1 = Division(1, fact);\r\n\r\n      // (lambda/miu)^n\r\n      let div = Division(this.lambda, this.miu);\r\n      let poten = Power(div, i);\r\n\r\n      let operation = item1 * poten;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The probability Pk that an arriving unit will have to wait\r\n  private getPk(): number {\r\n    // (1/k!)\r\n    let item1 = Division(1, Factorial(this.k));\r\n\r\n    // (lambda/miu)^k\r\n    let item2 = Power(Division(this.lambda, this.miu), this.k);\r\n\r\n    // ((k*miu)/(k*miu-lambda))\r\n    let numerator = this.k * this.miu;\r\n    let denominator = this.k * this.miu - this.lambda;\r\n    let item3 = Division(numerator, denominator);\r\n\r\n    // item1*item2*item3*P0\r\n    return item1 * item2 * item3 * this.p0;\r\n  }\r\n\r\n  // The probability Pn of finding exactly n customers in the system\r\n  private getPn(system: SystemOrQueuing, typeCalculate: TypeCalculate): number {\r\n    // Calculate Pn to finding client on System\r\n    if (system === SystemOrQueuing.System) {\r\n      // fixed SYSTEM\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n);\r\n      }\r\n\r\n      // max SYSTEM\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n          // console.log('MAX SYSTEM', value, i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least SYSTEM\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i < this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n    // Calculate Pn to finding client on Queuing\r\n    if (system === SystemOrQueuing.Queuing) {\r\n      // fixed Queuing\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n + this.k);\r\n      }\r\n\r\n      // max Queuing\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        let end = this.n + this.k;\r\n        for (let i = 0; i <= end; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least Queuing\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  private basicPn(n: number): number {\r\n    if (n < this.k) {\r\n      return this.calculatePnWhenNLessK(n);\r\n    } else {\r\n      return this.calculatePnWhenNHigherK(n);\r\n    }\r\n  }\r\n\r\n  private calculatePnWhenNLessK(n: number): number {\r\n    // (P0/n!)\r\n    let item1 = Division(this.p0, Factorial(n));\r\n\r\n    // (lambda/miu)^n\r\n    let item2 = Power(Division(this.lambda, this.miu), n);\r\n\r\n    // item1 * item2\r\n    return item1 * item2;\r\n  }\r\n\r\n  private calculatePnWhenNHigherK(n: number): number {\r\n    // (1/(k!(k)^n-k))\r\n    let fact = Factorial(this.k);\r\n    let pow = Power(this.k, n - this.k);\r\n    let item1 = Division(1, fact * pow);\r\n\r\n    // (lambda/miu)^n\r\n    let item2 = Power(Division(this.lambda, this.miu), n);\r\n\r\n    // item1*item2*P0\r\n    return item1 * item2 * this.p0;\r\n  }\r\n\r\n  // The expected number L of clients in the system\r\n  private getL(): number {\r\n    // (lambda/miu)\r\n    let lambdaDivMiu = Division(this.lambda, this.miu);\r\n\r\n    // lambda*miu*((lambda/miu)^k)\r\n    let pow = Power(lambdaDivMiu, this.k);\r\n    let numerator = this.lambda * this.miu * pow;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    let subItem1 = Division(numerator, denominator);\r\n\r\n    // subItem1*P0\r\n    let item1 = subItem1 * this.p0;\r\n\r\n    // item1+(lambda/miu)\r\n    return item1 + lambdaDivMiu;\r\n  }\r\n\r\n  // The expected number Lq of clients in the queue\r\n  private getLq(): number {\r\n    // lambda*miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.lambda * this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    return Division(numerator, denominator);\r\n  }\r\n\r\n  // The expected number Ln of clients in the non-empty queue\r\n  private getLn(): number {\r\n    return Division(this.lq, this.pk);\r\n  }\r\n\r\n  // The expected average time W in the system by the clients\r\n  private getW(): number {\r\n    // miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    let item1 = Division(numerator, denominator);\r\n\r\n    // (1/miu)\r\n    let item2 = Division(1, this.miu);\r\n\r\n    // item1+item2\r\n    return item1 + item2;\r\n  }\r\n\r\n  // The expected time Wq in the queue by the clients\r\n  private getWq(): number {\r\n    // miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    return Division(numerator, denominator);\r\n  }\r\n\r\n  // The expected time Wn in the queue for queues not empty by clients\r\n  private getWn(): number {\r\n    return Division(this.wq, this.pk);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}