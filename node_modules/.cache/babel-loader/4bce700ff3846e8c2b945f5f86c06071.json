{"ast":null,"code":"import { SystemOrQueuing, TypeCalculate } from '../Constants';\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\nexport class MMKModel {\n  // basic values\n  // results\n  constructor(lambda, miu, k, n = 0, horas = 0, espera = 0, sistema = 0, servidor = 0) {\n    this.lambda = void 0;\n    this.miu = void 0;\n    this.k = void 0;\n    this.n = void 0;\n    this.horas = void 0;\n    this.espera = void 0;\n    this.sistema = void 0;\n    this.servidor = void 0;\n    this.p0 = 0;\n    this.pk = 0;\n    this.pne = 0;\n    this.pn = 0;\n    this.lq = 0;\n    this.l = 0;\n    this.wq = 0;\n    this.w = 0;\n    this.wn = 0;\n    this.ln = 0;\n    this.costoServidor = 0;\n    this.costoSistema = 0;\n    this.costoCola = 0;\n    this.lambda = lambda;\n    this.miu = miu;\n    this.k = k;\n    this.n = n;\n    this.horas = horas;\n    this.espera = espera;\n    this.sistema = sistema;\n    this.servidor = servidor;\n  }\n\n  isMultichannel() {\n    return this.k > 1;\n  }\n\n  isStatable() {\n    let denominator = this.k * this.miu;\n    let condition = Division(this.lambda, denominator);\n    return condition < 1;\n  }\n\n  async calculateAll(system = SystemOrQueuing.System, typeCalculate = TypeCalculate.Fixed) {\n    this.p0 = this.getP0();\n    this.pk = this.getPk();\n    this.pne = 1 - this.pk;\n    this.pn = this.getPn(system, typeCalculate);\n    this.l = this.getL();\n    this.lq = this.getLq();\n    this.ln = this.getLn();\n    this.w = this.getW();\n    this.wq = this.getWq();\n    this.wn = this.getWn();\n    this.costoCola = this.lambda * this.horas * this.wq * this.espera;\n    this.co;\n  } // The probability P0 of finding the empty or idle system\n\n\n  getP0() {\n    // summation\n    let summation = this.summationForP0(); // (1/k!)\n\n    let fact = Factorial(this.k);\n    let subItem1 = Division(1, fact); // (lambda/miu)^k\n\n    let div = Division(this.lambda, this.miu);\n    let subItem2 = Power(div, this.k); // ((k*miu)/(k*miu-lambda))\n\n    let numerator = this.k * this.miu;\n    let denominator = this.k * this.miu - this.lambda;\n    let subItem3 = Division(numerator, denominator);\n    let item2 = subItem1 * subItem2 * subItem3;\n    return Division(1, summation + item2);\n  }\n\n  summationForP0() {\n    let value = 0;\n\n    for (let i = 0; i <= parseInt(this.k.toString()) - 1; i++) {\n      // (1/n!)\n      let fact = Factorial(i);\n      let item1 = Division(1, fact); // (lambda/miu)^n\n\n      let div = Division(this.lambda, this.miu);\n      let poten = Power(div, i);\n      let operation = item1 * poten;\n      value += operation;\n    }\n\n    return value;\n  } // The probability Pk that an arriving unit will have to wait\n\n\n  getPk() {\n    // (1/k!)\n    let item1 = Division(1, Factorial(this.k)); // (lambda/miu)^k\n\n    let item2 = Power(Division(this.lambda, this.miu), this.k); // ((k*miu)/(k*miu-lambda))\n\n    let numerator = this.k * this.miu;\n    let denominator = this.k * this.miu - this.lambda;\n    let item3 = Division(numerator, denominator); // item1*item2*item3*P0\n\n    return item1 * item2 * item3 * this.p0;\n  } // The probability Pn of finding exactly n customers in the system\n\n\n  getPn(system, typeCalculate) {\n    // Calculate Pn to finding client on System\n    if (system === SystemOrQueuing.System) {\n      // fixed SYSTEM\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n);\n      } // max SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i); // console.log('MAX SYSTEM', value, i);\n        }\n\n        return value;\n      } // at least SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i < this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    } // Calculate Pn to finding client on Queuing\n\n\n    if (system === SystemOrQueuing.Queuing) {\n      // fixed Queuing\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n + this.k);\n      } // max Queuing\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n        let end = this.n + this.k;\n\n        for (let i = 0; i <= end; i++) {\n          value += this.basicPn(i);\n        }\n\n        return value;\n      } // at least Queuing\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    }\n\n    return 0;\n  }\n\n  basicPn(n) {\n    if (n < this.k) {\n      return this.calculatePnWhenNLessK(n);\n    } else {\n      return this.calculatePnWhenNHigherK(n);\n    }\n  }\n\n  calculatePnWhenNLessK(n) {\n    // (P0/n!)\n    let item1 = Division(this.p0, Factorial(n)); // (lambda/miu)^n\n\n    let item2 = Power(Division(this.lambda, this.miu), n); // item1 * item2\n\n    return item1 * item2;\n  }\n\n  calculatePnWhenNHigherK(n) {\n    // (1/(k!(k)^n-k))\n    let fact = Factorial(this.k);\n    let pow = Power(this.k, n - this.k);\n    let item1 = Division(1, fact * pow); // (lambda/miu)^n\n\n    let item2 = Power(Division(this.lambda, this.miu), n); // item1*item2*P0\n\n    return item1 * item2 * this.p0;\n  } // The expected number L of clients in the system\n\n\n  getL() {\n    // (lambda/miu)\n    let lambdaDivMiu = Division(this.lambda, this.miu); // lambda*miu*((lambda/miu)^k)\n\n    let pow = Power(lambdaDivMiu, this.k);\n    let numerator = this.lambda * this.miu * pow; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    let subItem1 = Division(numerator, denominator); // subItem1*P0\n\n    let item1 = subItem1 * this.p0; // item1+(lambda/miu)\n\n    return item1 + lambdaDivMiu;\n  } // The expected number Lq of clients in the queue\n\n\n  getLq() {\n    // lambda*miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.lambda * this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    return Division(numerator, denominator);\n  } // The expected number Ln of clients in the non-empty queue\n\n\n  getLn() {\n    return Division(this.lq, this.pk);\n  } // The expected average time W in the system by the clients\n\n\n  getW() {\n    // miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    let item1 = Division(numerator, denominator); // (1/miu)\n\n    let item2 = Division(1, this.miu); // item1+item2\n\n    return item1 + item2;\n  } // The expected time Wq in the queue by the clients\n\n\n  getWq() {\n    // miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    return Division(numerator, denominator);\n  } // The expected time Wn in the queue for queues not empty by clients\n\n\n  getWn() {\n    return Division(this.wq, this.pk);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jhonc/Desktop/CALCULADORA/queueing-theory-calculator/src/library/queueing/formulas/MMK.model.ts"],"names":["SystemOrQueuing","TypeCalculate","Division","Factorial","Power","MMKModel","constructor","lambda","miu","k","n","horas","espera","sistema","servidor","p0","pk","pne","pn","lq","l","wq","w","wn","ln","costoServidor","costoSistema","costoCola","isMultichannel","isStatable","denominator","condition","calculateAll","system","System","typeCalculate","Fixed","getP0","getPk","getPn","getL","getLq","getLn","getW","getWq","getWn","co","summation","summationForP0","fact","subItem1","div","subItem2","numerator","subItem3","item2","value","i","parseInt","toString","item1","poten","operation","item3","basicPn","Max","AtLeast","Queuing","end","calculatePnWhenNLessK","calculatePnWhenNHigherK","pow","lambdaDivMiu","prod","square"],"mappings":"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","sourcesContent":["import { SystemOrQueuing, TypeCalculate } from '../Constants';\r\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\r\n\r\nexport class MMKModel {\r\n  // basic values\r\n  readonly lambda: number;\r\n  readonly miu: number;\r\n  readonly k: number;\r\n  readonly n: number;\r\n  readonly horas: number;\r\n  readonly espera: number;\r\n  readonly sistema: number;\r\n  readonly servidor: number;\r\n  // results\r\n  p0: number = 0;\r\n  pk: number = 0;\r\n  pne: number = 0;\r\n\r\n  pn: number = 0;\r\n  lq: number = 0;\r\n  l: number = 0;\r\n  wq: number = 0;\r\n  w: number = 0;\r\n  wn: number = 0;\r\n  ln: number = 0;\r\n  costoServidor =0;\r\n  costoSistema =0;\r\n  costoCola =0;\r\n\r\n  constructor(lambda: number, miu: number, k: number, n: number = 0, horas: number = 0, espera: number = 0, sistema: number = 0, servidor: number = 0) {\r\n    this.lambda = lambda;\r\n    this.miu = miu;\r\n    this.k = k;\r\n    this.n = n;\r\n    this.horas = horas;\r\n    this.espera = espera;\r\n    this.sistema = sistema;\r\n    this.servidor = servidor;\r\n  }\r\n\r\n  isMultichannel(): boolean {\r\n    return this.k > 1;\r\n  }\r\n\r\n  isStatable(): boolean {\r\n    let denominator = this.k * this.miu;\r\n    let condition = Division(this.lambda, denominator);\r\n    return condition < 1;\r\n  }\r\n\r\n  async calculateAll(\r\n    system: SystemOrQueuing = SystemOrQueuing.System,\r\n    typeCalculate: TypeCalculate = TypeCalculate.Fixed,\r\n  ): Promise<void> {\r\n    this.p0 = this.getP0();\r\n    this.pk = this.getPk();\r\n    this.pne = 1 - this.pk;\r\n    this.pn = this.getPn(system, typeCalculate);\r\n    this.l = this.getL();\r\n    this.lq = this.getLq();\r\n    this.ln = this.getLn();\r\n    this.w = this.getW();\r\n    this.wq = this.getWq();\r\n    this.wn = this.getWn();\r\n    this.costoCola = this.lambda * this.horas * this.wq * this.espera;\r\n    this.co\r\n  }\r\n\r\n  // The probability P0 of finding the empty or idle system\r\n  private getP0(): number {\r\n    // summation\r\n    let summation = this.summationForP0();\r\n\r\n    // (1/k!)\r\n    let fact = Factorial(this.k);\r\n\r\n    let subItem1 = Division(1, fact);\r\n\r\n    // (lambda/miu)^k\r\n    let div = Division(this.lambda, this.miu);\r\n    let subItem2 = Power(div, this.k);\r\n\r\n    // ((k*miu)/(k*miu-lambda))\r\n    let numerator = this.k * this.miu;\r\n    let denominator = this.k * this.miu - this.lambda;\r\n    let subItem3 = Division(numerator, denominator);\r\n\r\n    let item2 = subItem1 * subItem2 * subItem3;\r\n\r\n    return Division(1, summation + item2);\r\n  }\r\n\r\n  private summationForP0(): number {\r\n    let value = 0;\r\n    for (let i = 0; i <= parseInt(this.k.toString()) - 1; i++) {\r\n      // (1/n!)\r\n      let fact = Factorial(i);\r\n      let item1 = Division(1, fact);\r\n\r\n      // (lambda/miu)^n\r\n      let div = Division(this.lambda, this.miu);\r\n      let poten = Power(div, i);\r\n\r\n      let operation = item1 * poten;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The probability Pk that an arriving unit will have to wait\r\n  private getPk(): number {\r\n    // (1/k!)\r\n    let item1 = Division(1, Factorial(this.k));\r\n\r\n    // (lambda/miu)^k\r\n    let item2 = Power(Division(this.lambda, this.miu), this.k);\r\n\r\n    // ((k*miu)/(k*miu-lambda))\r\n    let numerator = this.k * this.miu;\r\n    let denominator = this.k * this.miu - this.lambda;\r\n    let item3 = Division(numerator, denominator);\r\n\r\n    // item1*item2*item3*P0\r\n    return item1 * item2 * item3 * this.p0;\r\n  }\r\n\r\n  // The probability Pn of finding exactly n customers in the system\r\n  private getPn(system: SystemOrQueuing, typeCalculate: TypeCalculate): number {\r\n    // Calculate Pn to finding client on System\r\n    if (system === SystemOrQueuing.System) {\r\n      // fixed SYSTEM\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n);\r\n      }\r\n\r\n      // max SYSTEM\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n          // console.log('MAX SYSTEM', value, i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least SYSTEM\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i < this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n    // Calculate Pn to finding client on Queuing\r\n    if (system === SystemOrQueuing.Queuing) {\r\n      // fixed Queuing\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n + this.k);\r\n      }\r\n\r\n      // max Queuing\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        let end = this.n + this.k;\r\n        for (let i = 0; i <= end; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least Queuing\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  private basicPn(n: number): number {\r\n    if (n < this.k) {\r\n      return this.calculatePnWhenNLessK(n);\r\n    } else {\r\n      return this.calculatePnWhenNHigherK(n);\r\n    }\r\n  }\r\n\r\n  private calculatePnWhenNLessK(n: number): number {\r\n    // (P0/n!)\r\n    let item1 = Division(this.p0, Factorial(n));\r\n\r\n    // (lambda/miu)^n\r\n    let item2 = Power(Division(this.lambda, this.miu), n);\r\n\r\n    // item1 * item2\r\n    return item1 * item2;\r\n  }\r\n\r\n  private calculatePnWhenNHigherK(n: number): number {\r\n    // (1/(k!(k)^n-k))\r\n    let fact = Factorial(this.k);\r\n    let pow = Power(this.k, n - this.k);\r\n    let item1 = Division(1, fact * pow);\r\n\r\n    // (lambda/miu)^n\r\n    let item2 = Power(Division(this.lambda, this.miu), n);\r\n\r\n    // item1*item2*P0\r\n    return item1 * item2 * this.p0;\r\n  }\r\n\r\n  // The expected number L of clients in the system\r\n  private getL(): number {\r\n    // (lambda/miu)\r\n    let lambdaDivMiu = Division(this.lambda, this.miu);\r\n\r\n    // lambda*miu*((lambda/miu)^k)\r\n    let pow = Power(lambdaDivMiu, this.k);\r\n    let numerator = this.lambda * this.miu * pow;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    let subItem1 = Division(numerator, denominator);\r\n\r\n    // subItem1*P0\r\n    let item1 = subItem1 * this.p0;\r\n\r\n    // item1+(lambda/miu)\r\n    return item1 + lambdaDivMiu;\r\n  }\r\n\r\n  // The expected number Lq of clients in the queue\r\n  private getLq(): number {\r\n    // lambda*miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.lambda * this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    return Division(numerator, denominator);\r\n  }\r\n\r\n  // The expected number Ln of clients in the non-empty queue\r\n  private getLn(): number {\r\n    return Division(this.lq, this.pk);\r\n  }\r\n\r\n  // The expected average time W in the system by the clients\r\n  private getW(): number {\r\n    // miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    let item1 = Division(numerator, denominator);\r\n\r\n    // (1/miu)\r\n    let item2 = Division(1, this.miu);\r\n\r\n    // item1+item2\r\n    return item1 + item2;\r\n  }\r\n\r\n  // The expected time Wq in the queue by the clients\r\n  private getWq(): number {\r\n    // miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    return Division(numerator, denominator);\r\n  }\r\n\r\n  // The expected time Wn in the queue for queues not empty by clients\r\n  private getWn(): number {\r\n    return Division(this.wq, this.pk);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}