{"ast":null,"code":"import { SystemOrQueuing, TypeCalculate } from '../Constants';\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\nexport class MMKModel {\n  // basic values\n  // results\n  constructor(lambda, miu, k, n = 0) {\n    this.lambda = void 0;\n    this.miu = void 0;\n    this.k = void 0;\n    this.n = void 0;\n    this.p0 = 0;\n    this.pk = 0;\n    this.pne = 0;\n    this.pn = 0;\n    this.lq = 0;\n    this.l = 0;\n    this.wq = 0;\n    this.w = 0;\n    this.wn = 0;\n    this.ln = 0;\n    this.lambda = lambda;\n    this.miu = miu;\n    this.k = k;\n    this.n = n;\n  }\n\n  isMultichannel() {\n    return this.k > 1;\n  }\n\n  isStatable() {\n    let denominator = this.k * this.miu;\n    let condition = Division(this.lambda, denominator);\n    return condition < 1;\n  }\n\n  async calculateAll(system = SystemOrQueuing.System, typeCalculate = TypeCalculate.Fixed) {\n    this.p0 = this.getP0();\n    this.pk = this.getPk();\n    this.pne = 1 - this.pk;\n    this.pn = this.getPn(system, typeCalculate);\n    this.l = this.getL();\n    this.lq = this.getLq();\n    this.ln = this.getLn();\n    this.w = this.getW();\n    this.wq = this.getWq();\n    this.wn = this.getWn();\n  } // The probability P0 of finding the empty or idle system\n\n\n  getP0() {\n    // summation\n    let summation = this.summationForP0(); // (1/k!)\n\n    let fact = Factorial(this.k);\n    let subItem1 = Division(1, fact); // (lambda/miu)^k\n\n    let div = Division(this.lambda, this.miu);\n    let subItem2 = Power(div, this.k); // ((k*miu)/(k*miu-lambda))\n\n    let numerator = this.k * this.miu;\n    let denominator = this.k * this.miu - this.lambda;\n    let subItem3 = Division(numerator, denominator);\n    let item2 = subItem1 * subItem2 * subItem3;\n    return Division(1, summation + item2);\n  }\n\n  summationForP0() {\n    let value = 0;\n\n    for (let i = 0; i <= parseInt(this.k.toString()) - 1; i++) {\n      // (1/n!)\n      let fact = Factorial(i);\n      let item1 = Division(1, fact); // (lambda/miu)^n\n\n      let div = Division(this.lambda, this.miu);\n      let poten = Power(div, i);\n      let operation = item1 * poten;\n      value += operation;\n    }\n\n    return value;\n  } // The probability Pk that an arriving unit will have to wait\n\n\n  getPk() {\n    // (1/k!)\n    let item1 = Division(1, Factorial(this.k)); // (lambda/miu)^k\n\n    let item2 = Power(Division(this.lambda, this.miu), this.k); // ((k*miu)/(k*miu-lambda))\n\n    let numerator = this.k * this.miu;\n    let denominator = this.k * this.miu - this.lambda;\n    let item3 = Division(numerator, denominator); // item1*item2*item3*P0\n\n    return item1 * item2 * item3 * this.p0;\n  } // The probability Pn of finding exactly n customers in the system\n\n\n  getPn(system, typeCalculate) {\n    // Calculate Pn to finding client on System\n    if (system === SystemOrQueuing.System) {\n      // fixed SYSTEM\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n);\n      } // max SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i); // console.log('MAX SYSTEM', value, i);\n        }\n\n        return value;\n      } // at least SYSTEM\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i < this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    } // Calculate Pn to finding client on Queuing\n\n\n    if (system === SystemOrQueuing.Queuing) {\n      // fixed Queuing\n      if (typeCalculate === TypeCalculate.Fixed) {\n        return this.basicPn(this.n + this.k);\n      } // max Queuing\n\n\n      if (typeCalculate === TypeCalculate.Max) {\n        let value = 0;\n        let end = this.n + this.k;\n\n        for (let i = 0; i <= end; i++) {\n          value += this.basicPn(i);\n        }\n\n        return value;\n      } // at least Queuing\n\n\n      if (typeCalculate === TypeCalculate.AtLeast) {\n        let value = 0;\n\n        for (let i = 0; i <= this.n; i++) {\n          value += this.basicPn(i);\n        }\n\n        return 1 - value;\n      }\n    }\n\n    return 0;\n  }\n\n  basicPn(n) {\n    if (n < this.k) {\n      return this.calculatePnWhenNLessK(n);\n    } else {\n      return this.calculatePnWhenNHigherK(n);\n    }\n  }\n\n  calculatePnWhenNLessK(n) {\n    // (P0/n!)\n    let item1 = Division(this.p0, Factorial(n)); // (lambda/miu)^n\n\n    let item2 = Power(Division(this.lambda, this.miu), n); // item1 * item2\n\n    return item1 * item2;\n  }\n\n  calculatePnWhenNHigherK(n) {\n    // (1/(k!(k)^n-k))\n    let fact = Factorial(this.k);\n    let pow = Power(this.k, n - this.k);\n    let item1 = Division(1, fact * pow); // (lambda/miu)^n\n\n    let item2 = Power(Division(this.lambda, this.miu), n); // item1*item2*P0\n\n    return item1 * item2 * this.p0;\n  } // The expected number L of clients in the system\n\n\n  getL() {\n    // (lambda/miu)\n    let lambdaDivMiu = Division(this.lambda, this.miu); // lambda*miu*((lambda/miu)^k)\n\n    let pow = Power(lambdaDivMiu, this.k);\n    let numerator = this.lambda * this.miu * pow; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    let subItem1 = Division(numerator, denominator); // subItem1*P0\n\n    let item1 = subItem1 * this.p0; // item1+(lambda/miu)\n\n    return item1 + lambdaDivMiu;\n  } // The expected number Lq of clients in the queue\n\n\n  getLq() {\n    // lambda*miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.lambda * this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    return Division(numerator, denominator);\n  } // The expected number Ln of clients in the non-empty queue\n\n\n  getLn() {\n    return Division(this.lq, this.pk);\n  } // The expected average time W in the system by the clients\n\n\n  getW() {\n    // miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    let item1 = Division(numerator, denominator); // (1/miu)\n\n    let item2 = Division(1, this.miu); // item1+item2\n\n    return item1 + item2;\n  } // The expected time Wq in the queue by the clients\n\n\n  getWq() {\n    // miu*((lambda/miu)^k)*P0\n    let pow = Power(Division(this.lambda, this.miu), this.k);\n    let numerator = this.miu * pow * this.p0; // (k-1)!(k*miu-lambda)^2\n\n    let fact = Factorial(this.k - 1);\n    let prod = this.k * this.miu - this.lambda;\n    let square = Power(prod, 2);\n    let denominator = fact * square; // numerator/denominator\n\n    return Division(numerator, denominator);\n  } // The expected time Wn in the queue for queues not empty by clients\n\n\n  getWn() {\n    return Division(this.wq, this.pk);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/jhonc/Desktop/CALCULADORA/queueing-theory-calculator/src/library/queueing/formulas/MMK.model.ts"],"names":["SystemOrQueuing","TypeCalculate","Division","Factorial","Power","MMKModel","constructor","lambda","miu","k","n","p0","pk","pne","pn","lq","l","wq","w","wn","ln","isMultichannel","isStatable","denominator","condition","calculateAll","system","System","typeCalculate","Fixed","getP0","getPk","getPn","getL","getLq","getLn","getW","getWq","getWn","summation","summationForP0","fact","subItem1","div","subItem2","numerator","subItem3","item2","value","i","parseInt","toString","item1","poten","operation","item3","basicPn","Max","AtLeast","Queuing","end","calculatePnWhenNLessK","calculatePnWhenNHigherK","pow","lambdaDivMiu","prod","square"],"mappings":"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","sourcesContent":["import { SystemOrQueuing, TypeCalculate } from '../Constants';\r\nimport { Division, Factorial, Power } from './../../../utils/MathUtils';\r\n\r\nexport class MMKModel {\r\n  // basic values\r\n  readonly lambda: number;\r\n  readonly miu: number;\r\n  readonly k: number;\r\n  readonly n: number;\r\n  // results\r\n  p0: number = 0;\r\n  pk: number = 0;\r\n  pne: number = 0;\r\n\r\n  pn: number = 0;\r\n  lq: number = 0;\r\n  l: number = 0;\r\n  wq: number = 0;\r\n  w: number = 0;\r\n  wn: number = 0;\r\n  ln: number = 0;\r\n\r\n  constructor(lambda: number, miu: number, k: number, n: number = 0) {\r\n    this.lambda = lambda;\r\n    this.miu = miu;\r\n    this.k = k;\r\n    this.n = n;\r\n  }\r\n\r\n  isMultichannel(): boolean {\r\n    return this.k > 1;\r\n  }\r\n\r\n  isStatable(): boolean {\r\n    let denominator = this.k * this.miu;\r\n    let condition = Division(this.lambda, denominator);\r\n    return condition < 1;\r\n  }\r\n\r\n  async calculateAll(\r\n    system: SystemOrQueuing = SystemOrQueuing.System,\r\n    typeCalculate: TypeCalculate = TypeCalculate.Fixed,\r\n  ): Promise<void> {\r\n    this.p0 = this.getP0();\r\n    this.pk = this.getPk();\r\n    this.pne = 1 - this.pk;\r\n    this.pn = this.getPn(system, typeCalculate);\r\n    this.l = this.getL();\r\n    this.lq = this.getLq();\r\n    this.ln = this.getLn();\r\n    this.w = this.getW();\r\n    this.wq = this.getWq();\r\n    this.wn = this.getWn();\r\n  }\r\n\r\n  // The probability P0 of finding the empty or idle system\r\n  private getP0(): number {\r\n    // summation\r\n    let summation = this.summationForP0();\r\n\r\n    // (1/k!)\r\n    let fact = Factorial(this.k);\r\n\r\n    let subItem1 = Division(1, fact);\r\n\r\n    // (lambda/miu)^k\r\n    let div = Division(this.lambda, this.miu);\r\n    let subItem2 = Power(div, this.k);\r\n\r\n    // ((k*miu)/(k*miu-lambda))\r\n    let numerator = this.k * this.miu;\r\n    let denominator = this.k * this.miu - this.lambda;\r\n    let subItem3 = Division(numerator, denominator);\r\n\r\n    let item2 = subItem1 * subItem2 * subItem3;\r\n\r\n    return Division(1, summation + item2);\r\n  }\r\n\r\n  private summationForP0(): number {\r\n    let value = 0;\r\n    for (let i = 0; i <= parseInt(this.k.toString()) - 1; i++) {\r\n      // (1/n!)\r\n      let fact = Factorial(i);\r\n      let item1 = Division(1, fact);\r\n\r\n      // (lambda/miu)^n\r\n      let div = Division(this.lambda, this.miu);\r\n      let poten = Power(div, i);\r\n\r\n      let operation = item1 * poten;\r\n      value += operation;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // The probability Pk that an arriving unit will have to wait\r\n  private getPk(): number {\r\n    // (1/k!)\r\n    let item1 = Division(1, Factorial(this.k));\r\n\r\n    // (lambda/miu)^k\r\n    let item2 = Power(Division(this.lambda, this.miu), this.k);\r\n\r\n    // ((k*miu)/(k*miu-lambda))\r\n    let numerator = this.k * this.miu;\r\n    let denominator = this.k * this.miu - this.lambda;\r\n    let item3 = Division(numerator, denominator);\r\n\r\n    // item1*item2*item3*P0\r\n    return item1 * item2 * item3 * this.p0;\r\n  }\r\n\r\n  // The probability Pn of finding exactly n customers in the system\r\n  private getPn(system: SystemOrQueuing, typeCalculate: TypeCalculate): number {\r\n    // Calculate Pn to finding client on System\r\n    if (system === SystemOrQueuing.System) {\r\n      // fixed SYSTEM\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n);\r\n      }\r\n\r\n      // max SYSTEM\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n          // console.log('MAX SYSTEM', value, i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least SYSTEM\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i < this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n    // Calculate Pn to finding client on Queuing\r\n    if (system === SystemOrQueuing.Queuing) {\r\n      // fixed Queuing\r\n      if (typeCalculate === TypeCalculate.Fixed) {\r\n        return this.basicPn(this.n + this.k);\r\n      }\r\n\r\n      // max Queuing\r\n      if (typeCalculate === TypeCalculate.Max) {\r\n        let value = 0;\r\n        let end = this.n + this.k;\r\n        for (let i = 0; i <= end; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return value;\r\n      }\r\n\r\n      // at least Queuing\r\n      if (typeCalculate === TypeCalculate.AtLeast) {\r\n        let value = 0;\r\n        for (let i = 0; i <= this.n; i++) {\r\n          value += this.basicPn(i);\r\n        }\r\n        return 1 - value;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  private basicPn(n: number): number {\r\n    if (n < this.k) {\r\n      return this.calculatePnWhenNLessK(n);\r\n    } else {\r\n      return this.calculatePnWhenNHigherK(n);\r\n    }\r\n  }\r\n\r\n  private calculatePnWhenNLessK(n: number): number {\r\n    // (P0/n!)\r\n    let item1 = Division(this.p0, Factorial(n));\r\n\r\n    // (lambda/miu)^n\r\n    let item2 = Power(Division(this.lambda, this.miu), n);\r\n\r\n    // item1 * item2\r\n    return item1 * item2;\r\n  }\r\n\r\n  private calculatePnWhenNHigherK(n: number): number {\r\n    // (1/(k!(k)^n-k))\r\n    let fact = Factorial(this.k);\r\n    let pow = Power(this.k, n - this.k);\r\n    let item1 = Division(1, fact * pow);\r\n\r\n    // (lambda/miu)^n\r\n    let item2 = Power(Division(this.lambda, this.miu), n);\r\n\r\n    // item1*item2*P0\r\n    return item1 * item2 * this.p0;\r\n  }\r\n\r\n  // The expected number L of clients in the system\r\n  private getL(): number {\r\n    // (lambda/miu)\r\n    let lambdaDivMiu = Division(this.lambda, this.miu);\r\n\r\n    // lambda*miu*((lambda/miu)^k)\r\n    let pow = Power(lambdaDivMiu, this.k);\r\n    let numerator = this.lambda * this.miu * pow;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    let subItem1 = Division(numerator, denominator);\r\n\r\n    // subItem1*P0\r\n    let item1 = subItem1 * this.p0;\r\n\r\n    // item1+(lambda/miu)\r\n    return item1 + lambdaDivMiu;\r\n  }\r\n\r\n  // The expected number Lq of clients in the queue\r\n  private getLq(): number {\r\n    // lambda*miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.lambda * this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    return Division(numerator, denominator);\r\n  }\r\n\r\n  // The expected number Ln of clients in the non-empty queue\r\n  private getLn(): number {\r\n    return Division(this.lq, this.pk);\r\n  }\r\n\r\n  // The expected average time W in the system by the clients\r\n  private getW(): number {\r\n    // miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    let item1 = Division(numerator, denominator);\r\n\r\n    // (1/miu)\r\n    let item2 = Division(1, this.miu);\r\n\r\n    // item1+item2\r\n    return item1 + item2;\r\n  }\r\n\r\n  // The expected time Wq in the queue by the clients\r\n  private getWq(): number {\r\n    // miu*((lambda/miu)^k)*P0\r\n    let pow = Power(Division(this.lambda, this.miu), this.k);\r\n    let numerator = this.miu * pow * this.p0;\r\n    // (k-1)!(k*miu-lambda)^2\r\n    let fact = Factorial(this.k - 1);\r\n    let prod = this.k * this.miu - this.lambda;\r\n    let square = Power(prod, 2);\r\n    let denominator = fact * square;\r\n    // numerator/denominator\r\n    return Division(numerator, denominator);\r\n  }\r\n\r\n  // The expected time Wn in the queue for queues not empty by clients\r\n  private getWn(): number {\r\n    return Division(this.wq, this.pk);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}